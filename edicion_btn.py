# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Edicion_Btn
                                 A QGIS plugin
 Este Plugin Permite la descarga y edicion controlada de la BTN
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-01-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Antonio Moreno Palacios
        email                : ammorenopalacios@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Importar todos los módulos necesarios para la ejecución del PLUGIN
from PyQt5.QtCore import  QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.gui import QgsMapTool, QgsMapToolPan, QgsMapToolEmitPoint, QgsRubberBand, QgsVertexMarker
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.PyQt.QtSql import QSqlDatabase
from qgis.PyQt.QtXml import QDomDocument
from qgis.core import *
from qgis.gui import QgsMapTool, QgsMapToolPan, QgsMapToolEmitPoint, QgsRubberBand, QgsVertexMarker
from qgis.utils import *
import collections
import time
import sys
import math
import inspect
from functools import partial
import base64
# Inicializar el archivo QT resources desde el archivo resources.py
from .resources import *

# Importar todas las clases que generan el entorno gráfico del PLUGIN. Previamente diseñadas en QT Designer
from .edicion_btn_dockwidget import Edicion_BtnDockWidget
from .Edicion_Btn_login import  Edicion_BtnDockWidgetLogin
from .Edicion_Btn_databasewindow import EdicionBtnDockWidgetDatabase
from .Edicion_Btn_typewindow import EdicionBtnDockWidgetType
from .Edicion_Btn_deletewindow import EdicionBtnDockWidgetDelete
from .Edicion_Btn_dockwidget2 import EdicionBtnDockWidget2
from .Edicion_Btn_conflictwindow import EdicionBtnConflictWindow
from .Edicion_Btn_change_user_project import EdicionBtnDockWidgetOwner
from .Edicion_Btn_table_internal import EdicionBtn_table_internal
from .Edicion_Btn_conflictwindow_interno import EdicionBtn_ConflictWindow_Interno
import os.path
#Clase principal del Plugin desde donde se genera toda la lógica
class Edicion_Btn:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Varaible que recibe el elemento IFACE de QGIS, que es toda la interfaz de QGIS.
        self.iface = iface

        # Inicializar el directorio principal del PLUGIN
        self.plugin_dir = os.path.dirname(__file__)

        # Inicializar al usuario local.
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Edicion_Btn_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&EdicionBtn')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Edicion_Btn')
        self.toolbar.setObjectName(u'Edicion_Btn')

        #Declatar todas las variables necesarias para la ejecución del PLUGIN

        self.pluginIsActive = False
        self.dockwidget = None
        # Variable para sabe si el usuario se ha logeado en la BBDD
        self.logged = False
        self.loginwindow = None
        self.dockwidget2 = None
        self.dockwidget3 = None
        self.conflictwindow = None
        self.loginwindow = None
        self.logged = False
        self.db = None
        self.databasewindow = None
        self.deletewindow = None
        self.typewindow = None
        self.annotationwindow = None
        self.version = "3.22.0"
        self.error = False
        self.admin = False
        self.loaded_proyect = None
        self.loaded_type = None
        self.easter = None
        self.easter_counter = 0
        self.project_clave = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Edicion_Btn', message)
    #Método en el que añaden todas las funcionalidades del PLUGIN a la barra de tareas de QGIS
    def add_action(self, name, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setObjectName(name)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    #Método para crear todas las funcionalidades del PLUGIN a su propia barra de tareas en QGIS.
    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # action para pan, para poder activarlo al cambiar entre botones
        actionPan = QAction("Pan", self.iface.mainWindow())
        actionPan.setCheckable(True)
        self.toolPan = QgsMapToolPan(self.iface.mapCanvas())
        self.toolPan.setAction(actionPan)

        icon_path = ':/plugins/edicion_btn/img_download.png'
        self.add_action(
            'download',
            icon_path,
            text=self.tr(u'Edicion BTN Download Project Data'),
            callback=self.download,
            parent=self.iface.mainWindow())
        icon_path = ':/plugins/edicion_btn/img_upload.png'
        self.add_action(
            'upload',
            icon_path,
            text=self.tr(u'Edicion BTN Commit Changes'),
            callback=self.upload,
            parent=self.iface.mainWindow())

        icon_path = ':/plugins/edicion_btn/img_adm_proy.png'
        self.add_action(
            'adm_proxy',
            icon_path,
            text=self.tr(u'Edicion BTN Change Project Owner'),
            callback=self.run_admin_project,
            parent=self.iface.mainWindow())

        icon_path = ':/plugins/edicion_btn/img_delete.png'
        self.add_action(
            'delete',
            icon_path,
            text=self.tr(u'Edicion BTN Delete working tables'),
            callback=self.run_delete_tables,
            parent=self.iface.mainWindow())


    #--------------------------------------------------------------------------
    #Método que cerrará las ventanas creadas cuando sea necesario.
    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING Edicion_Btn"

        # disconnects
        if self.dockwidget is not None:
            self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)
            self.dockwidget = None

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    #Método para quitar el plugin de la barra de tareas.
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD Edicion_Btn"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&EdicionBtn'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    #Metodo que carga e inicializa el PLUGIN
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING Edicion_Btn"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = Edicion_BtnDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
    #Método que al pulsar sobre el botón download llama al método login en caso de no estar conectado y sino a la selección del tipo de proyecto con el método select_type.
    def download(self):
        self.deactivate()
        self.iface.mapCanvas().setMapTool(self.toolPan)
        """Run method that loads and starts the plugin"""
        if not self.logged:
            self.login("download")
            return
        self.select_type()
        pass
    #Método que genera la interfaz gráfica para conectarse a la BBDD
    def login(self, origen):
        self.iface.messageBar().pushMessage("Error: ", "Please login to PostgreeSQL ", level=Qgis.Critical, duration=3)
        self.loginwindow = Edicion_BtnDockWidgetLogin()
        self.loginwindow.closingPlugin.connect(self.onClosePlugin)
        self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.loginwindow)
        #Línea de código que consiste en en llamar al método login_confirm una vez se ha introducido los parámetros de conexión a la BBDD
        self.loginwindow.pushButton.clicked.connect(lambda event: self.login_confirm(origen))
        self.loginwindow.show()
    #Método vacío para desactivar una determinada ventana gráfica.
    def deactivate(self):
        pass
    #Método para conectarse a la BBDD
    def connectDB(self):
        self.db = QSqlDatabase.addDatabase("QPSQL")
        self.db.setHostName(self.hostname)
        self.db.setPort(self.port)
        self.db.setDatabaseName(self.database)
        self.db.setUserName(self.user_u)
        self.db.setPassword(self.password_u)
        self.db.open()
    #Método para leer la información introducida en la ventana generada en el LOGIN.
    def login_confirm(self, origen):
        self.db = None
        self.hostname = "localhost"

        self.port = 5432
        self.user_u = self.loginwindow.lineEdit.text()
        self.password_u = self.loginwindow.lineEdit_2.text()
        self.user = 'postgres'
        #password codificado de la BBDD con permisos para realizar mas cosas de los que pueden hacer los usuarios editores
        self.password = "SjIwMjQkYW1w"
        self.password = base64.b64decode(self.password).decode('utf-8')
        self.database = "tfg"
        self.column_geom_muni = "the_geom"
        self.column_geom = "geometry"
        self.db = QSqlDatabase.addDatabase("QPSQL")

        self.db.setHostName(self.hostname)
        self.db.setPort(self.port)
        self.db.setDatabaseName(self.database)
        self.db.setUserName(self.user_u)
        self.db.setPassword(self.password_u)


        correcto = self.db.open()

        if not correcto:
            self.iface.messageBar().pushMessage("Error: ", "Error connecting to PostgreeSQL " + self.db.lastError().text(),level=Qgis.Critical)
        else:

            self.connectDB()
            self.loginwindow.close()
            self.select_database(origen)




    #Seleccionar la Base de Datos sobre la que se desea trabajar, está implementado para poder trabaja sobre BBDD de desarrollo o producción.
    def select_database(self, origen):
        #Se llama al metodo para conectarse a la BBDD
        self.connectDB()
        #En este caso solo existe una BBDD a la que conectarase
        listado = ["tfg"]

        #Generar el entorno gráfico de selección de BBDD
        self.databasewindow = EdicionBtnDockWidgetDatabase()
        self.databasewindow.closingPlugin.connect(self.onClosePlugin)
        self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.databasewindow)
        self.databasewindow.pushButton.clicked.connect(lambda event: self.database_confirm(origen))
        self.databasewindow.comboBox.addItems(listado)
        self.databasewindow.show()
    #Método que lee la base de datos seleccionada y llama a los métodos según la operación que haya seleccionado el usuario.
    def database_confirm(self, origen):
        self.database = str(self.databasewindow.comboBox.currentText())
        self.db.setDatabaseName(self.database)
        self.logged = True
        if origen == "download":
            self.databasewindow.close()
            self.download()
        elif origen == "commit":
            self.databasewindow.close()
            self.upload()
        elif origen == "run_delete_tables":
            self.databasewindow.close()
            self.run_delete_tables()
        elif origen == "run_admin_project":
            self.databasewindow.close()
            self.run_admin_project()

        pass
#Método que selecciona que tipo de proyectos se va a realizar Revision, el implementado o Calidad que se dejaria para futuras versiones.
    def select_type(self):
        listado = ["Revision", "Calidad"]
        #Genera el entorno gráfico para la seleccion del tipo de proyecto y llama a la función que ejecuta los pasos posteriores
        self.typewindow = EdicionBtnDockWidgetType()
        self.typewindow.closingPlugin.connect(self.onClosePlugin)
        self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.typewindow)
        self.typewindow.pushButton.clicked.connect(lambda event: self.select_type_confirm())
        self.typewindow.comboBox.addItems(listado)
        self.typewindow.show()
#Lectura del tipo de proyecto que selecciona el usuario, si selecciona calidad se muestra mensaje indicando que se desarrollará en futuras versiones.
    def select_type_confirm(self):
        ## Calidad todavia no se ha desarrollado
        if str(self.typewindow.comboBox.currentText()) == "Calidad":
            QMessageBox.critical(self.iface.mainWindow(), "Calidad", "It's not available yet it will available on next version")
            return

        if str(self.typewindow.comboBox.currentText()) == "Revision":
            self.loaded_type = "REV"

        self.typewindow.close()
        self.select_project()
        pass
#Método que genera el entorno gráfico para la descarga de la información de la BBDD según el tipo de proyecto seleccionado y genera los municipios de descarga a partir de la seleccion de la provincia.
    def select_project(self):
        if self.loaded_type in {"REV"}:
            if self.pluginIsActive and self.dockwidget is None:
                self.onClosePlugin()

            if not self.pluginIsActive:
                self.pluginIsActive = True
                if self.dockwidget is None:
                    self.dockwidget = Edicion_BtnDockWidget()

                self.dockwidget.closingPlugin.connect(self.onClosePlugin)
                self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
                self.dockwidget.show()

                self.dockwidget.cb_municipio.clear()
                self.dockwidget.list_tables.clear()
                self.dockwidget.list_queries.clear()
                self.connectDB()
                #Querie que devuelve los municipios de una provincia
                sql = "select a.codprov, a.nombre, b.id, b.municipio from provincia as a , municipios  as b"
                sql += " where a.codprov = b.codprov::text order by a.nombre, b.municipio;"
                query = self.db.exec_(sql)

                self.dict_provincia = collections.OrderedDict()
                self.dict_municipio = collections.OrderedDict()
                self.dockwidget.cb_municipio.clear()
                self.dockwidget.cb_municipio.setEnabled(False)
                self.dockwidget.cb_provincia.clear()
                listado_provincia = [""]
                self.dockwidget.cb_provincia.addItem("", None)

                while query.next():
                    self.dict_provincia[query.value(0)] = query.value(1)
                    if query.value(0) not in listado_provincia:
                        listado_provincia = listado_provincia + [query.value(0)]
                        self.dockwidget.cb_provincia.addItem(query.value(1), query.value(0))
                    self.dict_municipio[query.value(2)] = [query.value(3), query.value(0)]

                self.dockwidget.cb_provincia.currentIndexChanged[int].connect(self.related_municipio)
                self.dockwidget.cb_municipio.currentIndexChanged[int].connect(self.related_tables_project)

                self.dockwidget.pushButton.clicked.connect(self.download_data)



        pass
#Método que devuelve los municipios relacionados con la provincia seleccionada por el usuario.
    def related_municipio(self, provincia):
        self.dockwidget.cb_municipio.currentIndexChanged[int].disconnect(self.related_tables_project)
        self.dockwidget.cb_municipio.clear()
        self.dockwidget.cb_municipio.setEnabled(False)
        self.dockwidget.list_tables.clear()
        self.dockwidget.list_queries.clear()
        self.dockwidget.pushButton.setEnabled(False)
        self.dockwidget.cb_municipio.currentIndexChanged[int].connect(self.related_tables_project)
        if provincia == 0:
            return

        provincia_clave = str(self.dockwidget.cb_provincia.itemData(self.dockwidget.cb_provincia.currentIndex()))
        self.dockwidget.cb_municipio.addItem("", None)
        for municipio in self.dict_municipio:
            if self.dict_municipio[municipio][1] == provincia_clave:
                self.dockwidget.cb_municipio.addItem(self.dict_municipio[municipio][0], municipio)

        self.dockwidget.cb_municipio.currentIndexChanged[int].disconnect(self.related_tables_project)
        self.dockwidget.cb_municipio.setEnabled(True)
        self.dockwidget.cb_municipio.currentIndexChanged[int].connect(self.related_tables_project)
#Método que devuelve las tablas y consultas que se descargarán en el municipio elegido por el usuario
    def related_tables_project(self, project):
        self.dockwidget.list_tables.clear()
        self.dockwidget.list_queries.clear()
        self.dockwidget.pushButton.setEnabled(False)
        if project == 0:
            return

        # Parametros
        if self.loaded_type in {"REV"}:
            self.current_proyect = str(self.dockwidget.cb_municipio.currentText())
            self.tabla_proy = "municipios"
            self.tabla_proy_field = "id"
            self.project_clave = str(self.dockwidget.cb_municipio.itemData(self.dockwidget.cb_municipio.currentIndex()))

        # Tablas y queries (el orden de las tablas importa)
        if self.loaded_type == "REV":
            listado_incluidas = ['btn0590p_ser_ins', 'btn0525p_monume', 'btn0567p_ins_rec_p', 'btn0558p_yac_arq', 'btn0201l_cur_niv', 'btn0302l_rio',
                                 'btn0528l_cerram','btn0328s_alm_agu','btn0331s_dep_agu','btn0650s_est_fc','btn0508s_ed','btn0561s_zon_ver','btn0567s_ins_rec_s',
                                 'btn0564s_ins_dep','btn0513s_ins_ind','btn0504s_agr_edi','btn0522s_cement','btn0613s_inf_trans_s','btn0662s_pis_ater','btn0665s_zon_ater_s'
                                 ,'btn0302s_rio','btn0325s_embalse'
                                 ]
            listado_queries = ['query_btn0605l_carretera','query_btn0622l_urbana','query_btn0623l_camino','query_btn0626l_senda','query_btn0629l_car_bic',
                               'query_btn0632l_itiner','query_btn0635l_via_pec','query_btn0638l_fc_alt_vel','query_btn0641l_fc_conv',
                               'municipios']


        #Se añaden las tablas y consultas a la ventana gráfica de descarga del plugin
        self.dockwidget.list_tables.addItems(listado_incluidas)
        self.dockwidget.list_queries.addItems(listado_queries)

        self.dockwidget.list_tables.show()
        self.dockwidget.list_queries.show()
        self.dockwidget.pushButton.setEnabled(True)
#Método que realiza las consultas a la BBDD principal y crea las copias en el esquema proyectos solo de los datos del municipio seleccionado , comprueba si existe ese proyecto ya.
    def download_data(self):
        fecha_valor = str(time.strftime("%x") + " " + time.strftime("%X"))
        flag = "[%s][%s][%s][%s][%s]" % (
        "descargado", fecha_valor, self.user_u, self.loaded_type.lower(), self.current_proyect.lower())

        # Compruebo si la tabla de proyecto ya existe, en cuyo caso cojo su flag
        sql = "SELECT * FROM pg_catalog.pg_tables WHERE  schemaname = 'proyectos' AND tablename  = '%s_%s_%s'" % (
        self.user_u, self.loaded_type.lower(), self.current_proyect.lower())
        query = self.db.exec_(sql)
        if query.size() > 0:
            sql = "SELECT \"valor\" from \"proyectos\".\"%s\" WHERE tabla = 'flag';" % (
                        self.user_u + "_" + self.loaded_type.lower() + "_" + self.current_proyect.lower())
            query = self.db.exec_(sql)
            while query.next():
                flag = query.value(0)

        max_progress = self.dockwidget.list_queries.count() + self.dockwidget.list_tables.count() + 3
        progreso = self.showprogress("Loading tables and queries ...", max_progress)
        contador = 0

        # Carga las consultas desde public
        for elem in range(0, self.dockwidget.list_queries.count()):
            tabla = self.dockwidget.list_queries.item(elem).text()
            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Loading Query %s ..." % tabla, max_progress)
            progreso.setValue(contador)
            contador += 1

            sql = ""
            id_field = ""

            # Comprobamos que no esté ya añadida
            layers = QgsProject.instance().mapLayers().values()
            layer_list = []
            existe = False
            for layer in layers:
                if layer.name() == "[Query_" + self.current_proyect.lower() + "]_[" + tabla.lower() + "]":
                    QMessageBox.information(self.iface.mainWindow(), "Query already loaded",
                                            "Query already loaded\nQuery = %s \nProject = %s" % (
                                            tabla.lower(), self.current_proyect.lower()))
                    QgsMessageLog.logMessage("Query already loaded\nQuery = %s \nProject = %s" % (
                    tabla.lower(), self.current_proyect.lower()), 'Edicion BTN PLUGIN')
                    existe = True
                    break
            if existe:
                continue

            uri = QgsDataSourceUri()
            uri.setConnection(self.hostname, str(self.port), self.database, self.user_u, self.password_u)


            #Genera los códigos SQL para la descarga de los datos en forma de Query
            if tabla == "query_btn0605l_carretera":
                sql = "(select * from btn0605l_carretera where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0622l_urbana":
                sql = "(select * from btn0622l_urbana where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0623l_camino":
                sql = "(select * from btn0623l_camino where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0626l_senda":
                sql = "(select * from btn0626l_senda where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                    self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0629l_car_bic":
                sql = "(select * from btn0629l_car_bic where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                    self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0632l_itiner":
                sql = "(select * from btn0632l_itiner where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                    self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0635l_via_pec":
                sql = "(select * from btn0635l_via_pec where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                    self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0638l_fc_alt_vel":
                sql = "(select * from btn0638l_fc_alt_vel where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                    self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "query_btn0641l_fc_conv":
                sql = "(select * from btn0641l_fc_conv where ST_INTERSECTS((select the_geom from \"%s\" where \"%s\"  = '%s'), geometry))" % (
                    self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom, "", id_field)
            elif tabla == "municipios":
                sql = "(select * from municipios where ST_INTERSECTS(the_geom,(SELECT st_buffer(the_geom,0.001) "
                sql += "from \"%s\" where \"%s\" = '%s')))" % (
                self.tabla_proy, self.tabla_proy_field, self.project_clave)
                id_field = "id"
                uri.setDataSource("", sql, self.column_geom_muni, "", id_field)

            else:
                continue
            #Carga en la tabla de contenidos de QGIS de las consultas realizadas
            vlayer = QgsVectorLayer(uri.uri(), "[Query_" + self.current_proyect.lower() + "]_[" + tabla.lower() + "]",
                                    "postgres")
            QgsProject.instance().addMapLayer(vlayer)

        # Carga de tablas

        log = True
        working_tables_alert = False
        for elem in range(0, self.dockwidget.list_tables.count()):
            tabla = self.dockwidget.list_tables.item(elem).text()
            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Loading Table %s ..." % tabla, max_progress)
            progreso.setValue(contador)
            contador += 1

            sql = ""
            id_field = ""
            # Comprobamos que no esté ya añadida
            layers = QgsProject.instance().mapLayers().values()
            layer_list = []
            existe = False
            for layer in layers:
                if layer.name() == "[" + self.loaded_type.lower() + "_" + self.current_proyect.lower() + "]_[" + tabla.lower() + "]":
                    QMessageBox.information(self.iface.mainWindow(), "Table already loaded",
                                            "Table already loaded\nTable = %s \nProject = %s" % (
                                            tabla.lower(), self.current_proyect.lower()))
                    QgsMessageLog.logMessage("Table already loaded\nTable = %s \nProject = %s" % (
                    tabla.lower(), self.current_proyect.lower()), 'Edicion BTN PLUGIN')
                    existe = True
                    break
            if existe:  # Lo hacemos aparte para no continuar el for de capas, sino el de tablas
                continue

            # Consultamos tablas de trabajo en uso, e impedimos crear nuevas si otro usuario está trabajando esa tabla en ese proyecto
            if self.loaded_type.lower() in {"rev"}:
                sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and (table_name like '%%_rev_%s_%s' or table_name like '%%_rev_%s_%s') and (table_name not like '%s_%s_%s_%s') order by table_name;" % (
                self.current_proyect.lower(), tabla.lower(), self.current_proyect.lower(), tabla.lower(),
                self.user_u.lower(), self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())
            else:
                sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and table_name like '%%_%s_%s_%s' and table_name not like '%s_%s_%s_%s' order by table_name;" % (
                self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(), self.user_u.lower(),
                self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())
            query = self.db.exec_(sql)
            existe = False
            while query.next():
                temp = str(query.value(0))
                if self.loaded_type.lower() in {"rev"}:
                    user = temp.replace("_rev_" + self.current_proyect.lower() + "_" + tabla.lower(), "").replace(
                        "_rev_" + self.current_proyect.lower() + "_" + tabla.lower(), "")
                else:
                    user = temp.replace(
                        "_" + self.loaded_type.lower() + "_" + self.current_proyect.lower() + "_" + tabla.lower(), "")

                QMessageBox.critical(self.iface.mainWindow(), "Error creating working table",
                                     "Someone is already working on this village with same or conflict type\n\nUser = '%s' \nTable = '%s' \nProject = '%s'  \nType = '%s' \n'%s'" % (
                                     user, tabla.lower(), self.current_proyect.lower(), self.loaded_type.lower(), temp))
                QgsMessageLog.logMessage(
                    "Error creating working table\nSomeone is already working on this village with same or conflict type\n\nUser = '%s' \nTable = '%s' \nProject = '%s' \nType = '%s' \n'%s'" % (
                    user, tabla.lower(), self.current_proyect.lower(), self.loaded_type.lower(), temp),
                    'Edicion BTN PLUGIN')
                existe = True
                break

            if existe:
                self.borrar_tablas_capas(flag)
                self.iface.messageBar().clearWidgets()
                QMessageBox.critical(self.iface.mainWindow(), "Error",
                                     "Can't create required tables project, process cancelled")
                return

            # Obtenemos claves primarias
            sql = "SELECT pg_attribute.attname FROM pg_index, pg_class, pg_attribute, pg_namespace WHERE pg_class.oid = '%s'::regclass AND indrelid = pg_class.oid AND nspname = '%s' " % (
            tabla, 'public')
            sql += "and pg_class.relnamespace = pg_namespace.oid AND pg_attribute.attrelid = pg_class.oid AND pg_attribute.attnum = any(pg_index.indkey) AND indisprimary;"
            query = self.db.exec_(sql)
            primarias = ""
            primero = True
            while query.next():
                if not primero:
                    primarias += ","
                primarias += query.value(0)
                primero = False

            # Compruebo si la tabla de proyecto existe
            sql2 = "SELECT * FROM pg_catalog.pg_tables WHERE  schemaname = 'proyectos' AND tablename  = '%s_%s_%s'" % (
            self.user_u, self.loaded_type.lower(), self.current_proyect.lower())
            query2 = self.db.exec_(sql2)
            if query2.size() == 0:
                # Compruebo si la tabla no existe
                sql = "SELECT * FROM pg_catalog.pg_tables WHERE  schemaname = 'proyectos' AND tablename  = '%s_%s_%s_%s'" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())
                query = self.db.exec_(sql)
            else:
                # Compruebo si la tabla no existe y esta completamente cargada
                sql = "SELECT * FROM pg_catalog.pg_tables WHERE  schemaname = 'proyectos' AND tablename  = '%s_%s_%s_%s' and '%s' in (SELECT tabla from \"proyectos\".\"%s_%s_%s\" where valor='loaded')" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(), tabla.lower(),
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower())
                query = self.db.exec_(sql)

            # Si no existe creo las tablas a partir de las principales, y les asigno claves y permisos
            if query.size() == 0:
                # Drop if exists and not fully loaded
                sqlDrop = "DROP TABLE IF EXISTS \"proyectos\".\"%s_%s_%s_%s\" CASCADE;" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())
                queryDrop = self.db.exec_(sqlDrop)

                # Si log = True, registro la fecha y geometria
                if log:
                    self.writelog(self.user_u, self.loaded_type.lower() + "_" + self.current_proyect.lower(),
                                  "Proyecto (" + self.loaded_type.lower() + "_" + self.current_proyect.lower() + ") creado y asignado a " + self.user_u)

                    # Creamos tabla de datos min y max si no existe, debería de crearse antes, pero así aseguramos que solo exista cuando vaya a tener tablas el usuario
                    sql = "CREATE TABLE IF NOT EXISTS \"proyectos\".\"%s_%s_%s\" (tabla character varying NOT NULL, min_id integer,  max_id integer, valor character varying, CONSTRAINT \"%s_%s_%s_pkey\" PRIMARY KEY (tabla))" % (
                    self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), self.user_u,
                    self.loaded_type.lower(), self.current_proyect.lower())

                    query = self.db.exec_(sql)

                    sql = "INSERT INTO \"proyectos\".\"%s_%s_%s\"(tabla, valor) VALUES ('fecha','%s') ON CONFLICT ON CONSTRAINT \"%s_%s_%s_pkey\" DO NOTHING;" % (
                    self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), fecha_valor, self.user_u,
                    self.loaded_type.lower(), self.current_proyect.lower())
                    query = self.db.exec_(sql)

                    sql = "INSERT INTO \"proyectos\".\"%s_%s_%s\"(tabla, valor) VALUES ('flag', '%s') ON CONFLICT ON CONSTRAINT \"%s_%s_%s_pkey\" DO NOTHING;" % (
                    self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), flag, self.user_u,
                    self.loaded_type.lower(), self.current_proyect.lower())
                    query = self.db.exec_(sql)

                    sql = "INSERT INTO \"proyectos\".\"%s_%s_%s\"(tabla, valor) (SELECT 'geom', the_geom FROM \"public\".\"%s\" WHERE %s = '%s') ON CONFLICT ON CONSTRAINT \"%s_%s_%s_pkey\" DO NOTHING;" % (
                    self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), self.tabla_proy,
                    self.tabla_proy_field, self.project_clave, self.user_u, self.loaded_type.lower(),
                    self.current_proyect.lower())

                    query = self.db.exec_(sql)

                    log = False

                    # Actualizar proyecto
                    sql = "update \"public\".\"%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'') where %s = '%s' and COALESCE(flag,'') not like '%s%%';" % (
                    self.tabla_proy, flag, self.tabla_proy_field, self.project_clave, flag)
                    query = self.db.exec_(sql)
                    if query.lastError().isValid():
                        QgsMessageLog.logMessage("Error on updating flags for table " + self.tabla_proy + ":\n" + str(
                            query.lastError().text()), 'Edicion BTN PLUGIN')
                        QMessageBox.critical(self.conflictwindow, "Error: updating flags",
                                             "Error on updating flags for public " + self.tabla_proy + ", see log for more details")

                time.sleep(1)
                # Obtengo todas las columnas con la primaria delante
                sql = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + tabla.lower() + "' and table_schema = 'public' "
                sql += "and column_name not in ('" + primarias + "') order by ordinal_position;"
                query = self.db.exec_(sql)
                campos = [primarias]
                while query.next():
                    campos = campos + ['"' + tabla.lower() + '"."' + str(query.value(0)) + '"']
                campos = ", ".join(campos)



                sql = "SELECT %s " % campos
                sql += "INTO \"proyectos\".\"%s_%s_%s_%s\" " % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())
                sql += "FROM \"public\".%s " % (tabla.lower())

                if tabla in  ['btn0590p_ser_ins', 'btn0525p_monume', 'btn0567p_ins_rec_p', 'btn0558p_yac_arq', 'btn0201l_cur_niv', 'btn0302l_rio',
                                 'btn0528l_cerram','btn0328s_alm_agu','btn0331s_dep_agu','btn0650s_est_fc','btn0508s_ed','btn0561s_zon_ver','btn0567s_ins_rec_s',
                                 'btn0564s_ins_dep','btn0513s_ins_ind','btn0504s_agr_edi','btn0522s_cement','btn0613s_inf_trans_s','btn0662s_pis_ater','btn0665s_zon_ater_s'
                                 ,'btn0302s_rio','btn0325s_embalse'
                                 ]:
                    if tabla.split('_')[0].find('p')!=-1:
                        sql += "WHERE ST_Intersects((SELECT the_geom FROM \"public\".\"%s\" WHERE %s = '%s'),geometry);" % (
                        self.tabla_proy, self.tabla_proy_field, self.project_clave)
                        sql += "ALTER TABLE \"proyectos\".\"%s_%s_%s_%s\" ALTER COLUMN %s SET DEFAULT nextval('\"public\".\"%s_idprimary_seq\"'::regclass);" % (
                            self.user_u, self.loaded_type.lower(), self.current_proyect.lower(),tabla.lower(), primarias,tabla.lower()
                            )


                    elif tabla.split('_')[0].find('l')!=-1:
                        sql += "WHERE ST_Intersects((SELECT the_geom FROM \"public\".\"%s\" WHERE %s = '%s'),st_centroid(geometry));" % (
                            self.tabla_proy, self.tabla_proy_field, self.project_clave)
                        sql += "ALTER TABLE \"proyectos\".\"%s_%s_%s_%s\" ALTER COLUMN %s SET DEFAULT nextval('\"public\".\"%s_idprimary_seq\"'::regclass);" % (
                            self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(),
                            primarias, tabla.lower()
                        )



                    elif tabla.split('_')[0].find('s')!=-1:
                        sql += "WHERE ST_Intersects((SELECT the_geom FROM \"public\".\"%s\" WHERE %s = '%s'),st_centroid(geometry));" % (
                            self.tabla_proy, self.tabla_proy_field, self.project_clave)
                        sql += "ALTER TABLE \"proyectos\".\"%s_%s_%s_%s\" ALTER COLUMN %s SET DEFAULT nextval('\"public\".\"%s_idprimary_seq\"'::regclass);" % (
                            self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(),
                            primarias, tabla.lower()
                        )






                else:
                     continue
                #Se añaden clave primaria y se dan permisos además de crear indice espacial en las tablas descargadas de proyectos.
                sql += "ALTER TABLE \"proyectos\".\"%s_%s_%s_%s\" ADD PRIMARY KEY (%s);" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(), primarias)
                sql += "GRANT ALL ON TABLE \"proyectos\".\"%s_%s_%s_%s\" TO public;" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())
                sql += "CREATE INDEX \"%s_%s_%s_%s_geometry_geom_idx\" ON \"proyectos\".\"%s_%s_%s_%s\" USING gist (geometry);" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(), self.user_u,
                self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower())

                query = self.db.exec_(sql)

                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                        inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

                #Se genera la tabla de configuracion donde se guardan los ids para comprobar despues los nuevos añadidos.
                sql = "INSERT INTO \"proyectos\".\"%s_%s_%s\"(tabla, min_id, max_id) Select '%s', min(\"%s\"), max(\"%s\") FROM \"proyectos\".\"%s_%s_%s_%s\" ON CONFLICT ON CONSTRAINT \"%s_%s_%s_pkey\" DO NOTHING;" \
                        % (
                        self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(), primarias,
                        primarias, self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla.lower(),
                        self.user_u, self.loaded_type.lower(), self.current_proyect.lower())

                query = self.db.exec_(sql)



                # Actualizo los flags de las tablas
                tables = {'btn0590p_ser_ins':'idprimary', 'btn0525p_monume':'idprimary', 'btn0567p_ins_rec_p':'idprimary', 'btn0558p_yac_arq':'idprimary', 'btn0201l_cur_niv':'idprimary', 'btn0302l_rio':'idprimary',
                                 'btn0528l_cerram':'idprimary','btn0328s_alm_agu':'idprimary','btn0331s_dep_agu':'idprimary','btn0650s_est_fc':'idprimary','btn0508s_ed':'idprimary','btn0561s_zon_ver':'idprimary','btn0567s_ins_rec_s':'idprimary',
                                 'btn0564s_ins_dep':'idprimary','btn0513s_ins_ind':'idprimary','btn0504s_agr_edi':'idprimary','btn0522s_cement':'idprimary','btn0613s_inf_trans_s':'idprimary','btn0662s_pis_ater':'idprimary','btn0665s_zon_ater_s':'idprimary'
                                 ,'btn0302s_rio':'idprimary','btn0325s_embalse':'idprimary'
                                 }
                if tabla in tables:
                    # Compruebo si la tabla no existe
                    sql = "SELECT * FROM pg_catalog.pg_tables WHERE  schemaname = 'proyectos' AND tablename  = '%s_%s_%s_%s'; " % (
                    self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla)
                    query = self.db.exec_(sql)
                    # If exists
                    if query.size() > 0:


                        sql = "update \"public\".\"%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'') where %s in (SELECT %s from \"proyectos\".\"%s_%s_%s_%s\") and COALESCE(flag,'') not like '%s%%';" % (
                        tabla, flag, tables[tabla], tables[tabla], self.user_u, self.loaded_type.lower(),
                        self.current_proyect.lower(), tabla, flag)
                        sql += "update \"proyectos\".\"%s_%s_%s_%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'') where COALESCE(flag,'') not like '%s%%';" % (
                        self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla, flag, flag)
                        query = self.db.exec_(sql)
                        if query.lastError().isValid():
                            QgsMessageLog.logMessage(
                                    "Error on updating flags for table \"proyectos\".\"%s_%s_%s_%s\" " % (
                                    self.user_u, self.loaded_type.lower(), self.current_proyect.lower(),
                                    tabla.lower()) + ":\n" + str(query.lastError().text()), 'Edicion BTN PLUGIN')
                            QMessageBox.critical(self.conflictwindow, "Error: updating flags",
                                                     "Error on updating flags for table \"proyectos\".\"%s_%s_%s_%s\", see log for more details" % (
                                                     self.user_u, self.loaded_type.lower(),
                                                     self.current_proyect.lower(), tabla.lower()))
                            self.borrar_tablas_capas(flag)
                            return


                # se indica que las tablas se han cargado para saber su estado.
                sql = "update \"proyectos\".\"%s_%s_%s\" set \"valor\" = 'loaded' where tabla = '%s';" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla)
                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage(
                        "Error setting fully loaded state on proyect table:\n" + str(query.lastError().text()),
                        'Edicion BTN PLUGIN')
                    QMessageBox.critical(self.conflictwindow, "Error: updating flags",
                                         "Error setting fully loaded state on proyect table")
                    self.borrar_tablas_capas(flag)
                    return

            elif query.size() != 0:
                if not working_tables_alert:
                    QMessageBox.information(self.iface.mainWindow(), "Existing data found",
                                            "Existing data found, loading working tables")
                    working_tables_alert = True

            uri = QgsDataSourceUri()
            uri.setConnection(self.hostname, str(self.port), self.database, self.user_u, self.password_u)


            uri.setDataSource("proyectos",
                                  self.user_u + "_" + self.loaded_type.lower() + "_" + self.current_proyect.lower() + "_" + tabla.lower(),
                                  "geometry")

            vlayer = QgsVectorLayer(uri.uri(),
                                    "[" + self.loaded_type.lower() + "_" + self.current_proyect.lower() + "]_[" + tabla.lower() + "]",
                                    "postgres")
            QgsProject.instance().addMapLayer(vlayer)


        #Aplicamos los estilos que se han definido para cada tabla
        self.iface.messageBar().clearWidgets()
        progreso = self.showprogress("Applying layers style ...", max_progress)
        progreso.setValue(contador)
        contador += 1
        self.aplicarEstilos()
        #Ordenamos las capas para una visualizacion correcta
        self.iface.messageBar().clearWidgets()
        progreso = self.showprogress("Sorting layers ...", max_progress)
        progreso.setValue(contador)
        contador += 1
        self.reordenarCapas()
        #Actualizamos la visualización de las capas para que se vea correctamente
        self.iface.messageBar().clearWidgets()
        progreso = self.showprogress("Refresh layers ...", max_progress)
        progreso.setValue(contador)
        contador += 1

        self.refresh_layers()

        self.loaded_proyect = self.current_proyect
        self.dockwidget.close()
        self.iface.messageBar().clearWidgets()

        QMessageBox.information(self.iface.mainWindow(), "Complete", "Project Downloaded")

        pass
    #Método que genera la barra de progreso de cada una de las actuaciones que va haciendo el plugin, para información del usuario.
    def showprogress(self, text, limit):
        progressMessageBar = self.iface.messageBar().createMessage(text)
        progress = QProgressBar()
        progress.setMaximum(limit)
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        self.iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
        return progress
    #Método que refresca la visualización de las capas cargadas.
    def refresh_layers(self):
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            layer.triggerRepaint()
    #Método que escribe un log para en caso de errores saber que ha pasado.
    def writelog(self, usuario, proyecto, descripcion):
        fecha_valor = str(time.strftime("%x") + " " + time.strftime("%X"))
        app = "Edicion_Btn_Plugin"
        descripcion = str(descripcion)
        proyecto = str(proyecto)
        usuario = str(usuario)

        self.db = QSqlDatabase.addDatabase("QPSQL")
        self.db.setHostName(self.hostname)
        self.db.setPort(self.port)
        self.db.setDatabaseName("tfg")
        self.db.setUserName(self.user_u)
        self.db.setPassword(self.password_u)
        self.db.open()

        sql = "INSERT INTO \"log_apps\" (usuario, fecha, app, proyecto, descripcion) VALUES ('%s','%s','%s','%s','%s') ON CONFLICT ON CONSTRAINT \"log_apps_pkey\" DO NOTHING;" % (
        usuario, fecha_valor, app, proyecto, descripcion)
        query = self.db.exec_(sql)

        # recuperamos la base de datos seleccionada
        self.db.setDatabaseName(self.database)
        self.db.open()
  #Método gue genera la interfaz gráfica para eliminar un determinado proyecto.
    def run_delete_tables(self):
        self.deactivate()
        self.iface.mapCanvas().setMapTool(self.toolPan)

        if not self.logged:
            self.login("run_delete_tables")
            return
        if self.user_u =='postgres':
            self.admin = True
        if not self.admin:
            QMessageBox.warning(self.iface.mainWindow(), "Warning",
                                "Only admins can delete any project, this user can only delete projects from '" + self.user_u + "'")

        if self.pluginIsActive and self.deletewindow == None:
            self.onClosePlugin()

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.deletewindow is None:
                # Crear ventana de eliminar un proyecto
                self.deletewindow = EdicionBtnDockWidgetDelete()

            self.deletewindow.closingPlugin.connect(self.onClosePlugin)

            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.deletewindow)
            self.deletewindow.show()
            self.connectDB()
            self.deletewindow.comboBox.clear()
            project_list = [" "]
            sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and ((table_name like '%editor%' or table_name like '%postgres%' ) and table_name not like '%btn%')"
            if not self.admin:
                sql =  "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and (table_name like '%{}%'  and table_name not like '%btn%')".format(self.user_u)

            query = self.db.exec_(sql)

            while query.next():
                project_list = project_list + [query.value(0)]

            self.deletewindow.comboBox.addItems(project_list)
            self.deletewindow.pushButton.clicked.connect(self.delete_project)
            self.deletewindow.show()
#Método que elimina las tablas de un proyecto.
    def delete_project(self):
        project = str(self.deletewindow.comboBox.currentText())
        if project == " ":
            QMessageBox.warning(self.iface.mainWindow(), "Error", "No project selected")
            return

        reply = QMessageBox.question(self.iface.mainWindow(), 'Continue?',
                                     'All working tables will be deleted and all changes lost, for project (' + project + ') \nNew working tables will be generated next time on this project',
                                     QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.No:
            return

        flag = ""
        sql = "SELECT \"valor\" from \"proyectos\".\"%s\" WHERE tabla = 'flag';" % project
        query = self.db.exec_(sql)
        while query.next():
            flag = query.value(0)

        if flag != "":
            self.setCancelFlag(flag)

        delete = True
        intentos = 0

        while delete:
            intentos += 1
            sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' AND table_name like '%{}%'".format(project)

            query = self.db.exec_(sql)

            listado = []
            delete = False
            while query.next():
                delete = True
                listado = listado + [query.value(0)]

            if delete and intentos == 5:
                QMessageBox.information(self.iface.mainWindow(), "Error",
                                        "Error on delete project, contact admin to complete \"%s\" " % (project))
                QgsMessageLog.logMessage("Error on delete project, contact admin to complete \"%s\" " % (project),
                                         'Edición BTN PLUGIN')
                return

            for tabla_borrar in listado:
                sql = 'DROP TABLE proyectos."%s" CASCADE;' % (tabla_borrar)
                query = self.db.exec_(sql)

        self.deletewindow.close()
        self.writelog(self.user_u, project, u"El administrador " + self.user_u + u" elimina el proyecto: " + project)
        QMessageBox.information(self.iface.mainWindow(), "Done",
                                "Deleted all working tables related for project: \nProject = '%s'" % project)

    #Metodo que borra las tablas del esquema proyectos.
    def borrar_tablas_capas(self, flag):
        project = self.user_u + "_" + self.loaded_type.lower() + "_" + self.current_proyect.lower()

        self.setCancelFlag(flag)

        delete = True
        intentos = 0

        while delete:
            intentos += 1
            sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and table_name like '%{}%'" .format(
            project)
            query = self.db.exec_(sql)

            listado = []
            delete = False
            while query.next():
                delete = True
                listado = listado + [query.value(0)]

            if delete and intentos == 5:
                QMessageBox.information(self.iface.mainWindow(), "Error",
                                        "Error on delete project, contact admin to complete \"%s\" " % (project))
                QgsMessageLog.logMessage("Error on delete project, contact admin to complete \"%s\" " % (project),
                                         'Edicion BTN PLUGIN')
                return

            for tabla_borrar in listado:
                sql = 'DROP TABLE \"proyectos\"."%s" CASCADE;' % tabla_borrar
                query = self.db.exec_(sql)

        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if self.current_proyect.lower() in layer.name():
                QgsProject.instance().removeMapLayers([layer.id()])
    #Método que actualiza el flag de una tabla a cancelado cuando se elimina un proyecto.
    def setCancelFlag(self, flag_old):
        fecha_valor = str(time.strftime("%x") + " " + time.strftime("%X"))
        flag = "[cancelado][%s]" % (fecha_valor)
        if "[descargado]" in flag_old:
            flag += flag_old[31:]
        elif "[cancelado]" in flag_old:
            flag += flag_old[30:]
        elif "[posteado]" in flag_old:
            flag += flag_old[29:]

        # Actualizar el flag a cancelado
        tables = {'btn0590p_ser_ins', 'btn0525p_monume', 'btn0567p_ins_rec_p', 'btn0558p_yac_arq', 'btn0201l_cur_niv', 'btn0302l_rio',
                                 'btn0528l_cerram','btn0328s_alm_agu','btn0331s_dep_agu','btn0650s_est_fc','btn0508s_ed','btn0561s_zon_ver','btn0567s_ins_rec_s',
                                 'btn0564s_ins_dep','btn0513s_ins_ind','btn0504s_agr_edi','btn0522s_cement','btn0613s_inf_trans_s','btn0662s_pis_ater','btn0665s_zon_ater_s'
                                 ,'btn0302s_rio','btn0325s_embalse'}
        for tabla in tables:
            sql = "update \"public\".\"%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'') where COALESCE(\"flag\",'') like '%%%s%%';" % (
            tabla, flag, flag_old)

            query = self.db.exec_(sql)
#Método que aplica a las capas los estilos predeterminados que se encuentra en la tabla de BBDD layer_style.
    def aplicarEstilos(self):


        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            temp = layer.name()

            if temp.rfind("[") != -1:
                tabla_name = temp[temp.rfind("[") + 1:-1]

                QgsMessageLog.logMessage("Setting style to layer: " + tabla_name, 'Edicion BTN PLUGIN', Qgis.Info)

                ### LOAD STYLE FROM DB
                sql = "SELECT \"styleqml\" from \"layer_styles\" WHERE \"stylename\" = '%s' AND f_table_name = '%s';" % (
                tabla_name, self.loaded_type)
                QgsMessageLog.logMessage("Setting style to layer: " + tabla_name, 'Edicion BTN PLUGIN', Qgis.Info)
                query = self.db.exec_(sql)
                while query.next():
                    # applyNamedStyle Deprecated use importNamedStyle
                    # layer.applyNamedStyle(query.value(0))

                    styledoc = QDomDocument()
                    styledoc.setContent(query.value(0))
                    layer.importNamedStyle(styledoc)



                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                        inspect.currentframe().f_lineno), 'Edicion BTN  PLUGIN')

        pass
#Metodo que ordena las capas segun la lista  en la tabla de contenidos.
    def reordenarCapas(self):
        # Parametros
        if self.loaded_type in {"REV"}:
            orden = ['municipios','query_btn0641l_fc_conv','query_btn0638l_fc_alt_vel','query_btn0635l_via_pec','query_btn0632l_itiner','query_btn0629l_car_bic','query_btn0626l_senda'
                    ,'query_btn0623l_camino','query_btn0622l_urbana','query_btn0605l_carretera',
                     'btn0325s_embalse','btn0302s_rio','btn0665s_zon_ater_s','btn0662s_pis_ater','btn0650s_est_fc','btn0567s_ins_rec_s','btn0613s_inf_trans_s' ,
                     'btn0522s_cement','btn0504s_agr_edi','btn0513s_ins_ind', 'btn0564s_ins_dep','btn0561s_zon_ver','btn0508s_ed','btn0331s_dep_agu','btn0328s_alm_agu','btn0302l_rio',
                     'btn0528l_cerram','btn0201l_cur_niv', 'btn0558p_yac_arq', 'btn0567p_ins_rec_p', 'btn0525p_monume' ,'btn0590p_ser_ins']

        layers = QgsProject.instance().mapLayers().values()
        arbol = QgsProject.instance().layerTreeRoot()
        for item in orden:
            for layer in layers:
                temp = layer.name()
                if temp.rfind("[") != -1:
                    tabla_name = temp[temp.rfind("[") + 1:-1]
                    if tabla_name == item:
                        layer_arbol = arbol.findLayer(layer.id())
                        clone = layer_arbol.clone()
                        padre = layer_arbol.parent()
                        padre.insertChildNode(0, clone)
                        padre.removeChildNode(layer_arbol)
        pass
#Metodo que genera la interfaz gráfica para subir los cambios de un proyecto a la BBDD principal.
    def upload(self):
        """Run method that loads and starts the plugin"""
        self.deactivate()
        self.iface.mapCanvas().setMapTool(self.toolPan)

        if self.loaded_proyect is None:
            QMessageBox.critical(self.iface.mainWindow(), "Error", "No project loaded, download project first")
            return

        if not self.logged:
            self.login("commit")
            return

        if self.pluginIsActive and self.dockwidget2 is None:
            self.onClosePlugin()


        if self.dockwidget2 is not None:
            if self.easter_counter == 5:
                self.easter_start()
                self.easter_counter = 0
            else:
                self.easter_counter += 1
        else:
            self.easter_counter = 0
        ########

        if not self.pluginIsActive:
            self.pluginIsActive = True

            if self.dockwidget2 is None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget2 = EdicionBtnDockWidget2()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget2.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget2)
            self.dockwidget2.show()
            self.connectDB()

            self.dockwidget2.listWidget.clear()
            layers = QgsProject.instance().mapLayers().values()
            layer_list = []
            for layer in layers:
                if (layer.name()[:1] == "[") and ("[Query_" not in layer.name()):
                    layer_list.append(layer.name())
            self.dockwidget2.listWidget.addItems(layer_list)
            self.dockwidget2.pushButton.clicked.connect(self.show_changes)

        pass
#Método para reordenar las tablas.
    def reordenarItems(self, tablas):

        orden = ['btn0325s_embalse','btn0302s_rio','btn0665s_zon_ater_s','btn0662s_pis_ater','btn0650s_est_fc','btn0567s_ins_rec_s','btn0613s_inf_trans_s' ,
                     'btn0522s_cement','btn0504s_agr_edi','btn0513s_ins_ind', 'btn0564s_ins_dep','btn0561s_zon_ver','btn0508s_ed','btn0331s_dep_agu','btn0328s_alm_agu','btn0302l_rio',
                     'btn0528l_cerram','btn0201l_cur_niv', 'btn0558p_yac_arq', 'btn0567p_ins_rec_p', 'btn0525p_monume' ,'btn0590p_ser_ins']

        tabla_resultado = []
        for item in reversed(orden):
            for tabla in tablas:
                temp = tabla.text()
                tabla_name = temp[temp.rfind("[") + 1:-1]
                if tabla_name == item:
                    tabla_resultado = tabla_resultado + [tabla]

        for tabla in tablas:
            if tabla not in tabla_resultado:
                tabla_resultado = tabla_resultado + [tabla]

        return tabla_resultado
    #Método que actualiza cualquier campo con valor vacio a nulo, para facilidad de las consultas de comparación.
    def eliminarnulos(self):

        project = self.user_u + "_" + self.loaded_type.lower() + "_" + self.loaded_proyect.lower()

        sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and table_name like '%s%%' order by table_name; " % (
            project)
        self.connectDB()
        query = self.db.exec_(sql)
        if query.lastError().isValid():
            QgsMessageLog.logMessage(
                "Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(inspect.currentframe().f_lineno),
                'Edicion BTN PLUGIN')
            return

        while query.next():
            # Obtengo todas las columnas sin primaria
            sql2 = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + query.value(
                0) + "' and table_schema = 'proyectos' order by ordinal_position;"
            query2 = self.db.exec_(sql2)
            while query2.next():
                sql3 = "UPDATE \"proyectos\".\"" + query.value(0) + "\" SET \"" + str(
                    query2.value(0)) + "\" = NULL WHERE trim(\"" + str(query2.value(0)) + "\") = '';"
                query3 = self.db.exec_(sql3)
#Método que al subir el proyecto autorellena el campo etiqueta con el valor de campo nombre sino está vacío. Es un ejemplo de autocompletado de datos.
    def complete_buildings(self, project):
        error = False
        # Completar el campo etiqueta con el valor del campo nombre cuando no sea nulo y la etiqueta no sea nula
        sql = """update proyectos."{}_btn0508s_ed" set etiqueta = nombre where nombre is not null and etiqueta is null""".format(project)
        query = self.db.exec_(sql)
        if query.lastError().isValid():
            error = True
            QgsMessageLog.logMessage(
                "Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(inspect.currentframe().f_lineno),
                'Edicion BTN PLUGIN')
        return error
   #Metodo que genera la iterfaz gráfica de los conflictos encontrados.
    def conflictWindow(self):
        self.conWin = EdicionBtnConflictWindow()
        self.conWin.buttonBox.button(QDialogButtonBox.Save).hide()
        self.conWin.resize(550, 330)
        self.conWin.label.setText("Conflict Checker")
        self.conWin.setWindowTitle("Conflict Checker")
        for i in range(0, self.conWin.tabWidget.count()):
            self.conWin.tabWidget.removeTab(i)
        return self.conWin
    #Metodo que realiza un zoom a los conflictos encontrados al subir los cambios, para localizarlos y solucionarlos.
    def conflict_zoom(self, table, layerName, field):
        if len(table.selectedItems()) == 0:
            return

        layers = QgsProject.instance().mapLayers().values()
        value = table.selectedItems()[1].text()  # El id siempre es la segunda columna




        expr = "\"%s\" = '%s'" % (field, value)

        # Obtengo la capa de la tabla (omito las queries)
        for layer in layers:
            if (layer.name()[:1] == "[") and ("[" + layerName + "]" in layer.name()):
                layer.selectByExpression(expr)
                self.iface.mapCanvas().zoomToSelected(layer)
                self.iface.mapCanvas().refresh()
                break
#Método que chequea el valor de campos de la tabla edificios y comprueba qu sean correctos, es un ejemplo de control de edición.
    def check_building(self, window):
        project = self.user_u + "_" + self.loaded_type.lower() + "_" + self.loaded_proyect.lower()

        # Mostrar los valores erroneos de los campos de lista de calores

        sql = """select idprimary, case when tipo_0508 not in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508  in ('01','03')  and  fuent_0508  in ('01','02','03','04','05') then 'tipo_0508 field has wrong value'
when tipo_0508 not in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508  not in ('01','03')  and  fuent_0508  in ('01','02','03','04','05') then 'tipo_0508 and estad_0508 fields have wrong values'    
when tipo_0508 not in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508  not in ('01','03')  and  fuent_0508  not in ('01','02','03','04','05') then 'tipo_0508 ,estad_0508, fuent_0508 fields have wrong values'  
when tipo_0508  in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508  not in ('01','03')  and  fuent_0508  in ('01','02','03','04','05') then 'estad_0508 field has wrong value'
when tipo_0508  in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508  not in ('01','03')  and  fuent_0508 not in ('01','02','03','04','05') then 'estad_0508 and fuent_0508 fields have  wrong values'
when tipo_0508  not in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508   in ('01','03')  and  fuent_0508  not in ('01','02','03','04','05') then 'tipo_0508, fuent_0508 field have wrong values' 
 when tipo_0508  in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
and estad_0508  in ('01','03')  and  fuent_0508  not in ('01','02','03','04','05') then 'fuent_0508 field has wrong value'



end as error
from   "proyectos"."{}_btn0508s_ed"  where tipo_0508 not in ('03',
'04','05','01','06','07','08','09','11','12','13','14','15','16','17','18','19','20','21','30','22','23','24','25','26','27','28','29','30','31','32','33','34')
or estad_0508 not in ('01','03')  or fuent_0508 not in ('01','02','03','04','05')   """.format(project)
        self.connectDB()
        query = self.db.exec_(sql)
        if query.lastError().isValid():
            QgsMessageLog.logMessage(
                "Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(inspect.currentframe().f_lineno),
                'Edicion Btn PLUGIN')
        # print(sql)

        new_tab = QWidget()
        vBoxlayout = QVBoxLayout()
        interno = EdicionBtn_table_internal()
        vBoxlayout.addWidget(interno)
        new_tab.setLayout(vBoxlayout)
        primer_registro = True
        interno.tableWidget.setRowCount(0)
        interno.bt_zoom.clicked.connect(partial(self.conflict_zoom, interno.tableWidget, "btn0508s_ed", "idprimary"))
        while query.next():
            record = query.record()
            rowPosition = interno.tableWidget.rowCount()
            interno.tableWidget.insertRow(rowPosition)
            if primer_registro:
                interno.tableWidget.setColumnCount(3)
                interno.tableWidget.setHorizontalHeaderItem(0, QTableWidgetItem(u"Error Type"))
                interno.tableWidget.setHorizontalHeaderItem(1, QTableWidgetItem(u"Id"))
                interno.tableWidget.setHorizontalHeaderItem(2, QTableWidgetItem(u"Description"))

                primer_registro = False

            interno.tableWidget.setItem(rowPosition, 0, QTableWidgetItem(u"List Values Errors "))
            interno.tableWidget.setItem(rowPosition, 1, QTableWidgetItem(str(record.value(0))))
            interno.tableWidget.setItem(rowPosition, 2, QTableWidgetItem(str(record.value(1))))

        if interno.tableWidget.rowCount() != 0:
            interno.tableWidget.resizeColumnsToContents()
            window.tabWidget.addTab(new_tab, "Wrong values in list values layer btn0508s_ed ")
            self.error =True

#Método para realizar un zoom a un punto de intersección generado al vuelo, no es un registro de una tabla sino un punto generado por un error.
    def conflicto_zoom_punto(self, EdicionBtn_table_internal, columna_geom):


        if len(EdicionBtn_table_internal.selectedItems()) == 0:
            return

        i = 1
        while EdicionBtn_table_internal.selectedItems()[i].text() == "":
            i += 1

        layers = QgsProject.instance().mapLayers().values()
        value = EdicionBtn_table_internal.selectedItems()[i].text()
        layerName ='btn0201l_cur_niv'
        field = 'idprimary'


        expr = "\"%s\" = '%s'" % (field, value)

        # Obtengo la capa de la tabla (omito las queries)
        for layer in layers:
            if (layer.name()[:1] == "[") and ("[" + layerName + "]" in layer.name()):
                layer.selectByExpression(expr)

        coordenadas = EdicionBtn_table_internal.selectedItems()[columna_geom].text()
        coordenadas = coordenadas.replace('(', ' ').replace(')', ' ').split(' ')
        # print(coordenadas)
        x = float(coordenadas[1])
        y = float(coordenadas[2])
        scale = 0.00005

        canvas = iface.mapCanvas()
        rect = QgsRectangle(float(x) - scale, float(y) - scale, float(x) + scale, float(y) + scale)
        pt = QgsPoint(float(x), float(y))
        canvas.setExtent(rect)
        self.iface.mapCanvas().refresh()


#Método que comprueba que no existan cruces entre curvas de nivel, es otro ejemplo de comprobar la calidad de la edicion.
    def check_contours(self, window):
        project = self.user_u + "_" + self.loaded_type.lower() + "_" + self.loaded_proyect.lower()
        sql = """select min(w.id) as id , st_astext(w.geom) from 

(select a.id , 
(st_dump(st_force2d(st_intersection(a.geometry, b.geometry)))).geom as geom from proyectos."{}_btn0201l_cur_niv" as a , 
proyectos."{}_btn0201l_cur_niv" as b where a.idprimary<>b.idprimary and st_intersects(a.geometry,b.geometry) and a.cota_0201 <> b.cota_0201) as w  group by geom """.format(project,project)
        self.connectDB()

        query = self.db.exec_(sql)

        new_tab = QWidget()
        vBoxlayout = QVBoxLayout()
        interno = EdicionBtn_table_internal()
        vBoxlayout.addWidget(interno)
        new_tab.setLayout(vBoxlayout)
        primer_registro = True
        interno.tableWidget.setRowCount(0)
        interno.bt_zoom.clicked.connect(partial(self.conflicto_zoom_punto, interno.tableWidget, 3))
        while query.next():
            record = query.record()
            rowPosition = interno.tableWidget.rowCount()
            interno.tableWidget.insertRow(rowPosition)
            if primer_registro:
                interno.tableWidget.setColumnCount(4)
                interno.tableWidget.setHorizontalHeaderItem(0, QTableWidgetItem(u"Error Type"))
                interno.tableWidget.setHorizontalHeaderItem(1, QTableWidgetItem(u"Id"))
                interno.tableWidget.setHorizontalHeaderItem(2, QTableWidgetItem(u"Description"))
                interno.tableWidget.setHorizontalHeaderItem(3, QTableWidgetItem(u"Geom"))
                primer_registro = False

            interno.tableWidget.setItem(rowPosition, 0, QTableWidgetItem(u"Contour Intersection "))
            interno.tableWidget.setItem(rowPosition, 1, QTableWidgetItem(str(record.value(0))))
            interno.tableWidget.setItem(rowPosition, 2, QTableWidgetItem(u"Existing Intersection between contours"))
            interno.tableWidget.setItem(rowPosition, 3, QTableWidgetItem(str(record.value(1))))

        if interno.tableWidget.rowCount() != 0:
            interno.tableWidget.resizeColumnsToContents()
            window.tabWidget.addTab(new_tab, "Existing contour intersection on  layer btn0201l_cur_niv ")
            self.error =True

#Método que permite seleccionar todas los cambios para subir de una sola vez.
    def changeAll(self, tableWidget):
        all = True
        # Check first, if empty change all to checked, else empty
        widget = tableWidget.cellWidget(0, 0)
        for x in widget.children():
            if isinstance(x, QCheckBox):
                if x.isChecked():
                    all = False

        for id in range(0, tableWidget.rowCount()):
            widget = tableWidget.cellWidget(id, 0)
            for x in widget.children():
                if isinstance(x, QCheckBox):
                    if all:
                        x.setChecked(True)
                    else:
                        x.setChecked(False)


#Método que muestra los cambios que se han realizado en la edición, tb comprueba los conflictos.
    def show_changes(self):
        self.db = QSqlDatabase.addDatabase("QPSQL")
        self.db.setHostName(self.hostname)
        self.db.setPort(self.port)
        self.db.setDatabaseName(self.database)
        self.db.setUserName(self.user)
        self.db.setPassword(self.password)
        self.db.open()

        # Inicializamos la variable para sucesivos commit en caso de errores
        self.recheck = False

        self.deactivate()
        self.iface.mapCanvas().setMapTool(self.toolPan)



        self.refresh_layers()

        self.conflictwindow = EdicionBtnConflictWindow()
        self.conflictwindow.closingPlugin.connect(self.onClosePlugin)
        self.conflictwindowcheck = self.conflictWindow()
        # Dejo solo un tab para limpiar previos
        for i in range(0, self.conflictwindow.tabWidget.count()):
            self.conflictwindow.tabWidget.removeTab(i)

        self.dict_results = collections.OrderedDict()

        tablas = []
        for elem in range(0, self.dockwidget2.listWidget.count()):
            tablas.append(self.dockwidget2.listWidget.item(elem))
        # print(self.dockwidget2.listWidget.item(elem).text())

        tablas = self.reordenarItems(tablas)
        contador = 0
        progreso = self.showprogress("Detecting changes...", len(tablas))
        progreso.setValue(contador)
        project_name = self.loaded_proyect.lower()
        user = self.user_u

        flag_old = ""
        sql = "SELECT \"valor\" from \"proyectos\".\"%s\" WHERE tabla = 'flag';" % (
                    user + "_" + self.loaded_type.lower() + "_" + project_name)
        query = self.db.exec_(sql)

        while query.next():
            flag_old = query.value(0)
        self.iface.messageBar().clearWidgets()
        # comprobaciones y autocompletados
        QgsMessageLog.logMessage("Starting checking and autocomplete", 'Edicion BTN PLUGIN', Qgis.Info)
        progreso = self.showprogress("Checking and autocomplete data...", len(tablas))
        progreso.setValue(contador)
        self.eliminarnulos()


        if self.loaded_type in {"REV"}:
            if self.complete_buildings(user + "_" + self.loaded_type.lower() + "_" + project_name):
                self.iface.messageBar().clearWidgets()
                return

            if self.check_building( self.conflictwindowcheck):
                self.iface.messageBar().clearWidgets()
                return
            if self.check_contours( self.conflictwindowcheck):
                self.iface.messageBar().clearWidgets()
                return
            if self.conflictwindowcheck.tabWidget.count()>0:
                self.conflictwindowcheck.show()
                QMessageBox.critical(self.conflictwindowcheck, "Error", "Error checking the data fix it and upload the project again")
                self.iface.messageBar().clearWidgets()
                return False





        QgsMessageLog.logMessage("End of checking and autocomplete", 'Edicion BTN PLUGIN', Qgis.Info)



        # Si ha pasado las comprobaciones, seguimos con las comparaciones
        contador = 0
        for tabla in tablas:
            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Detecting changes...", len(tablas))
            progreso.setValue(contador)
            contador += 1
            temp = tabla.text()
            tabla_name = temp[temp.rfind("[") + 1:-1]

            # "Calculamos primaria"
            sql = "SELECT pg_attribute.attname FROM pg_index, pg_class, pg_attribute, pg_namespace WHERE pg_class.oid = '%s'::regclass AND indrelid = pg_class.oid AND nspname = '%s' " % (
            tabla_name, 'public')
            sql += "and pg_class.relnamespace = pg_namespace.oid AND pg_attribute.attrelid = pg_class.oid AND pg_attribute.attnum = any(pg_index.indkey) AND indisprimary;"

            query = self.db.exec_(sql)
            primarias = ""
            primero = True
            while query.next():
                if not primero:
                    primarias += ","
                primarias += query.value(0)
                primero = False

            new_tab = QWidget()
            vBoxlayout = QVBoxLayout()
            self.dict_results[tabla.text()] = EdicionBtn_ConflictWindow_Interno()
            vBoxlayout.addWidget(self.dict_results[tabla.text()])
            new_tab.setLayout(vBoxlayout)

            # Obtengo todas las columnas sin primaria
            sql = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + "' and table_schema = 'proyectos' "
            sql += "and column_name not in ('%s') " % primarias
            sql += "and column_name in (SELECT column_name FROM information_schema.columns WHERE table_name = '" + tabla_name + "' and table_schema = 'public' ) "
            sql += "order by ordinal_position;"

            query = self.db.exec_(sql)
            campos = []
            campos_public = []
            while query.next():
                campos = campos + [
                    '"' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '"."' + str(
                        query.value(0)) + '"']
                campos_public = campos_public + ['"' + tabla_name + '"."' + str(query.value(0)) + '"']
            campos = ", ".join(campos)
            campos_public = ", ".join(campos_public)

            # Calculamos nuevos con ID definitivo, por tanto cuyo id de primaria no exista en la principal
            sql = 'Select \'true\' AS "Commit", ' + primarias + ', ' + campos + ' from proyectos."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '" '
            sql += ' WHERE NOT EXISTS( Select "' + primarias + '" from "public"."' + tabla_name + '" as "secondary" where "secondary"."' + primarias + '" = "' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '"."' + primarias + '") '




            if tabla_name in ['btn0325s_embalse','btn0302s_rio','btn0665s_zon_ater_s','btn0662s_pis_ater','btn0650s_est_fc','btn0567s_ins_rec_s','btn0613s_inf_trans_s' ,
                     'btn0522s_cement','btn0504s_agr_edi','btn0513s_ins_ind', 'btn0564s_ins_dep','btn0561s_zon_ver','btn0508s_ed','btn0331s_dep_agu','btn0328s_alm_agu','btn0302l_rio',
                     'btn0528l_cerram','btn0201l_cur_niv', 'btn0558p_yac_arq', 'btn0567p_ins_rec_p', 'btn0525p_monume' ,'btn0590p_ser_ins'] and tabla_name.split('_')[0].find('p')!=-1:
                sql += "AND ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'), geometry) "

            else :
                sql += "AND ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'),st_centroid(geometry))"


            query = self.db.exec_(sql)
            if query.lastError().isValid():
                QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                    inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

            primer_registro = True
            self.dict_results[tabla.text()].tableWidget.setRowCount(0)
            self.dict_results[tabla.text()].bt_allnone_1.clicked.connect(partial(self.changeAll, self.dict_results[tabla.text()].tableWidget))
            while query.next():
                record = query.record()
                rowPosition = self.dict_results[tabla.text()].tableWidget.rowCount()
                self.dict_results[tabla.text()].tableWidget.insertRow(rowPosition)
                for i in range(0, record.count()):
                    if primer_registro:
                        self.dict_results[tabla.text()].tableWidget.setColumnCount(record.count())
                        self.dict_results[tabla.text()].tableWidget.setHorizontalHeaderItem(i, QTableWidgetItem(
                            str(record.fieldName(i))))
                        if i == 0:
                            self.dict_results[tabla.text()].tableWidget.setColumnWidth(i, 50)

                    if str(record.value(i)) != "NULL":
                        if i == 0:
                            qwidget = QWidget()
                            checkbox = QCheckBox()
                            checkbox.setCheckState(Qt.Checked)
                            qhboxlayout = QHBoxLayout(qwidget)
                            qhboxlayout.addWidget(checkbox)
                            qhboxlayout.setAlignment(Qt.AlignCenter)
                            qhboxlayout.setContentsMargins(0, 0, 0, 0)
                            self.dict_results[tabla.text()].tableWidget.setCellWidget(rowPosition, i, qwidget)
                        else:
                            self.dict_results[tabla.text()].tableWidget.setItem(rowPosition, i, QTableWidgetItem(str(record.value(i))))

                primer_registro = False

            if self.dict_results[tabla.text()].tableWidget.rowCount() == 0:
                self.dict_results[tabla.text()].setTabEnabled(0, False)
            else:
                self.dict_results[tabla.text()].setTabEnabled(0, True)
                self.dict_results[tabla.text()].setCurrentIndex(0)

            #  Calculamos eliminados
            sql = 'Select \'true\' AS "Commit", ' + primarias + ', ' + campos_public + ' from public."' + tabla_name + '" '

            # "Calculamos eliminados, cuyos id, de global, no aparezcan en temporal"
            if tabla_name in ['btn0325s_embalse','btn0302s_rio','btn0665s_zon_ater_s','btn0662s_pis_ater','btn0650s_est_fc','btn0567s_ins_rec_s','btn0613s_inf_trans_s' ,
                     'btn0522s_cement','btn0504s_agr_edi','btn0513s_ins_ind', 'btn0564s_ins_dep','btn0561s_zon_ver','btn0508s_ed','btn0331s_dep_agu','btn0328s_alm_agu','btn0302l_rio',
                     'btn0528l_cerram','btn0201l_cur_niv', 'btn0558p_yac_arq', 'btn0567p_ins_rec_p', 'btn0525p_monume' ,'btn0590p_ser_ins'] and tabla_name.split('_')[0].find('p')!=-1:
                sql += "WHERE ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'), geometry) "
            else :
                sql += "WHERE ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'), st_centroid(geometry)) "
            sql += ' AND NOT EXISTS( Select "' + primarias + '" from "proyectos"."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '" as "secondary" where "secondary"."' + primarias + '" = "' + tabla_name + '"."' + primarias + '") '
            sql += 'AND ' + primarias + ' <= (Select max_id::numeric from "proyectos"."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = '" + tabla_name + "') "
            sql += 'AND ' + primarias + ' >= (Select min_id::numeric from "proyectos"."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = '" + tabla_name + "'); "

            query = self.db.exec_(sql)
            if query.lastError().isValid():
                QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                    inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

            primer_registro = True
            self.dict_results[tabla.text()].tableWidget_2.setRowCount(0)
            self.dict_results[tabla.text()].bt_allnone_2.clicked.connect(
                partial(self.changeAll, self.dict_results[tabla.text()].tableWidget_2))
            while query.next():
                record = query.record()
                rowPosition = self.dict_results[tabla.text()].tableWidget_2.rowCount()
                self.dict_results[tabla.text()].tableWidget_2.insertRow(rowPosition)
                for i in range(0, record.count()):
                    if primer_registro:
                        self.dict_results[tabla.text()].tableWidget_2.setColumnCount(record.count())
                        self.dict_results[tabla.text()].tableWidget_2.setHorizontalHeaderItem(i, QTableWidgetItem(
                            str(record.fieldName(i))))
                        if i == 0:
                            self.dict_results[tabla.text()].tableWidget_2.setColumnWidth(i, 50)

                    if str(record.value(i)) != "NULL":
                        if i == 0:
                            qwidget = QWidget()
                            checkbox = QCheckBox()
                            checkbox.setCheckState(Qt.Checked)
                            qhboxlayout = QHBoxLayout(qwidget)
                            qhboxlayout.addWidget(checkbox)
                            qhboxlayout.setAlignment(Qt.AlignCenter)
                            qhboxlayout.setContentsMargins(0, 0, 0, 0)
                            self.dict_results[tabla.text()].tableWidget_2.setCellWidget(rowPosition, i, qwidget)
                        else:
                            self.dict_results[tabla.text()].tableWidget_2.setItem(rowPosition, i, QTableWidgetItem(
                                str(record.value(i))))

                    elif str(record.value(i)) == "NULL":
                        self.dict_results[tabla.text()].tableWidget_2.setItem(rowPosition, i, QTableWidgetItem(str("")))
                primer_registro = False

            if self.dict_results[tabla.text()].tableWidget_2.rowCount() == 0:
                self.dict_results[tabla.text()].setTabEnabled(1, False)
            else:
                self.dict_results[tabla.text()].setTabEnabled(1, True)
                self.dict_results[tabla.text()].setCurrentIndex(1)

            # Obtenemos nombres de campos comunes con la tabla de proyecto y la tabla principal
            sql = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + "' and table_schema = 'proyectos' "
            sql += "and column_name in (SELECT column_name FROM information_schema.columns WHERE table_name = '" + tabla_name + "' and table_schema = 'public' ) "
            sql += "order by ordinal_position;"

            query = self.db.exec_(sql)
            campos = []

            while query.next():
                campos = campos + [str(query.value(0))]

            # Calculamos cambios
            sql = 'Select \'true\' AS "Commit",'
            campos_temp = ""
            campos_original = ""
            primero = True
            for campo in campos:
                if not primero:
                    campos_temp += ' , '
                    campos_original += ' , '
                campos_temp += "temp." + campo
                campos_original += "original." + campo
                primero = False
            sql += campos_temp + ' , ' + campos_original
            sql += ' from public."' + tabla_name + '" as "original" RIGHT JOIN proyectos."' + user + '_' + self.loaded_type.lower() + "_" + project_name + '_' + tabla_name + '" as "temp" '
            sql += 'ON temp.' + primarias + ' = original.' + primarias
            sql += ' WHERE original.' + primarias + ' is not null '

            sql += ' and ('
            primero = True
            for campo in campos:
                if not primero:
                    sql += ' OR '
                if campo == self.column_geom:
                    sql += '((ST_ASTEXT(temp.%s) <> ST_ASTEXT(original.%s)) or (temp.%s is null and original.%s is not null) or (temp.%s is not null and original.%s is null))' % (
                    campo, campo, campo, campo, campo, campo)
                else:
                    sql += '((temp.%s <> original.%s) or (temp.%s is null and original.%s is not null) or (temp.%s is not null and original.%s is null))' % (
                    campo, campo, campo, campo, campo, campo)
                primero = False
            sql += ');'
            num_columnas_query = len(campos) + 1

            query = self.db.exec_(sql)
            if query.lastError().isValid():
                QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                    inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')
            primer_registro = True
            self.dict_results[tabla.text()].tableWidget_3.setRowCount(0)
            self.dict_results[tabla.text()].bt_allnone_3.clicked.connect(
                partial(self.changeAll, self.dict_results[tabla.text()].tableWidget_3))
            while query.next():
                record = query.record()
                rowPosition = self.dict_results[tabla.text()].tableWidget_3.rowCount()
                self.dict_results[tabla.text()].tableWidget_3.insertRow(rowPosition)
                error = False
                for i in range(0, num_columnas_query):
                    if primer_registro:
                        self.dict_results[tabla.text()].tableWidget_3.setColumnCount(num_columnas_query)
                        self.dict_results[tabla.text()].tableWidget_3.setHorizontalHeaderItem(i, QTableWidgetItem(
                            str(record.fieldName(i))))
                        if i == 0:
                            self.dict_results[tabla.text()].tableWidget_3.setColumnWidth(i, 50)

                    if i == 0:
                        qwidget = QWidget()
                        checkbox = QCheckBox()
                        checkbox.setCheckState(Qt.Checked)
                        qhboxlayout = QHBoxLayout(qwidget)
                        qhboxlayout.addWidget(checkbox)
                        qhboxlayout.setAlignment(Qt.AlignCenter)
                        qhboxlayout.setContentsMargins(0, 0, 0, 0)
                        self.dict_results[tabla.text()].tableWidget_3.setCellWidget(rowPosition, i, qwidget)
                    else:
                        if str(record.value(i + num_columnas_query - 1)) == "NULL" and i == 1:
                            self.dict_results[tabla.text()].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                str(record.value(i)) + " has been deleted in main table"))
                            self.dict_results[tabla.text()].tableWidget_3.setColumnWidth(i, 250)
                            error = True

                        elif str(record.value(i)) != "NULL" and str(
                                record.value(i + num_columnas_query - 1)) != "NULL" and (
                                str(record.value(i)) != str(record.value(i + num_columnas_query - 1))):
                            self.dict_results[tabla.text()].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                str(record.value(i + num_columnas_query - 1)) + " -> " + str(record.value(i))))
                            self.dict_results[tabla.text()].tableWidget_3.item(rowPosition, i).setBackground(
                                QColor(100, 200, 100))

                        elif str(record.value(i)) != "NULL" and str(
                                record.value(i + num_columnas_query - 1)) == "NULL" and i != 1:
                            self.dict_results[tabla.text()].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                str(record.value(i + num_columnas_query - 1)) + " -> " + str(record.value(i))))
                            self.dict_results[tabla.text()].tableWidget_3.item(rowPosition, i).setBackground(
                                QColor(100, 200, 100))

                        elif str(record.value(i)) == "NULL" and str(record.value(i + num_columnas_query - 1)) != "NULL":
                            self.dict_results[tabla.text()].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                str(record.value(i + num_columnas_query - 1)) + " -> " + str(record.value(i))))
                            self.dict_results[tabla.text()].tableWidget_3.item(rowPosition, i).setBackground(
                                QColor(100, 200, 100))

                        elif str(record.value(i)) == "NULL" and str(record.value(i + num_columnas_query - 1)) == "NULL":
                            self.dict_results[tabla.text()].tableWidget_3.setItem(rowPosition, i,
                                                                                  QTableWidgetItem(str("")))

                        else:
                            self.dict_results[tabla.text()].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                str(record.value(i))))

                        if error:
                            self.dict_results[tabla.text()].tableWidget_3.item(rowPosition, i).setBackground(
                                QColor(200, 0, 0))

                primer_registro = False

            if self.dict_results[tabla.text()].tableWidget_3.rowCount() == 0:
                self.dict_results[tabla.text()].setTabEnabled(2, False)
            else:
                self.dict_results[tabla.text()].setTabEnabled(2, True)
                self.dict_results[tabla.text()].setCurrentIndex(2)

            if self.dict_results[tabla.text()].tableWidget.rowCount() == 0 and self.dict_results[
                tabla.text()].tableWidget_2.rowCount() == 0 and self.dict_results[
                tabla.text()].tableWidget_3.rowCount() == 0:
                del self.dict_results[tabla.text()]
            else:
                self.conflictwindow.tabWidget.addTab(new_tab, tabla.text())

        self.iface.messageBar().clearWidgets()

        for tabla in self.dockwidget2.listWidget.selectedItems():
            tabla.setSelected(False)

        if self.conflictwindow.tabWidget.count() == 0:
            msgBox = QMessageBox(parent=self.iface.mainWindow())
            horizontalSpacer = QSpacerItem(200, 0, QSizePolicy.Minimum, QSizePolicy.Expanding)
            msgBox.setText("No changes detected on selected layers")
            msgBox.setWindowTitle("No changes detected")
            layout = msgBox.layout()
            layout.addItem(horizontalSpacer, layout.rowCount(), 0, 1, layout.columnCount())
            msgBox.exec_()
        else:
            self.conflictwindow.buttonBox.button(QDialogButtonBox.Save).clicked.connect(self.commit_changes)
            self.conflictwindow.show()
            self.conflictwindow.activateWindow()
            msgBox = QMessageBox(parent=self.conflictwindow)
            horizontalSpacer = QSpacerItem(200, 0, QSizePolicy.Minimum, QSizePolicy.Expanding)
            msgBox.setText("Select records for each tab to commit to main table")
            msgBox.setWindowTitle("Select records to commit")
            layout = msgBox.layout()
            layout.addItem(horizontalSpacer, layout.rowCount(), 0, 1, layout.columnCount())
            msgBox.exec_()
        pass
#Método que realiza las actualizaciones , insercciones o eliminaciones hechas en el proyecto sobre las tablas principales.
    def commit_changes(self):
        res = QMessageBox.warning(self.conflictwindow, "Selected records to commit","Only selected records in each table and category will be uploaded, continue?",                                  QMessageBox.No | QMessageBox.Yes)
        if res == QMessageBox.No:
            return

        self.db = QSqlDatabase.addDatabase("QPSQL")
        self.db.setHostName(self.hostname)
        self.db.setPort(self.port)
        self.db.setDatabaseName(self.database)
        self.db.setUserName(self.user)
        self.db.setPassword(self.password)
        correcto = self.db.open()
        if not correcto:
            self.iface.messageBar().pushMessage("Error: ", "Error connecting to PostgreeSQL ", level=Qgis.Critical,duration=3)
            return


        # Diccionario nuevo con los ids, para la recomprobación
        self.diccionario_ids_tabla = collections.OrderedDict()
        self.show_changes_tables = []

        # Oculto ventana anterior, para preparar barra para progresos
        self.conflictwindow.hide()

        for tabla in self.dict_results:
            ids_new = []
            ids_delete = []
            ids_mods = []

            temp = tabla
            tabla_name = temp[temp.rfind("[") + 1:-1]
            project_name = self.loaded_proyect.lower()
            user = self.user_u

            for id in range(0, self.dict_results[tabla].tableWidget.rowCount()):
                widget = self.dict_results[tabla].tableWidget.cellWidget(id, 0)
                for x in widget.children():
                    if isinstance(x, QCheckBox):
                        if x.isChecked():
                            ids_new = ids_new + [self.dict_results[tabla].tableWidget.item(id, 1).text()]

            for id in range(0, self.dict_results[tabla].tableWidget_2.rowCount()):
                widget = self.dict_results[tabla].tableWidget_2.cellWidget(id, 0)
                for x in widget.children():
                    if isinstance(x, QCheckBox):
                        if x.isChecked():
                            ids_delete = ids_delete + [self.dict_results[tabla].tableWidget_2.item(id, 1).text()]

            for id in range(0, self.dict_results[tabla].tableWidget_3.rowCount()):
                widget = self.dict_results[tabla].tableWidget_3.cellWidget(id, 0)
                for x in widget.children():
                    if isinstance(x, QCheckBox):
                        if x.isChecked():
                            ids_mods = ids_mods + [self.dict_results[tabla].tableWidget_3.item(id, 1).text()]

            # Guardo las referencias para el recheck
            if len(ids_new) > 0 or len(ids_delete) > 0 or len(ids_mods) > 0:
                self.show_changes_tables.append(tabla)
                self.diccionario_ids_tabla[tabla] = [ids_new, ids_delete, ids_mods]
            else:
                continue

            progreso = self.showprogress("Apply changes to " + str(tabla) + "...", 100)
            contador = 0

            # "Calculamos primaria para deletes y updates"
            sql = "SELECT pg_attribute.attname FROM pg_index, pg_class, pg_attribute, pg_namespace WHERE pg_class.oid = '%s'::regclass AND indrelid = pg_class.oid AND nspname = '%s' " % (
            "proyectos.\"" + user + '_' + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name +
            "\"", 'proyectos')
            sql += "and pg_class.relnamespace = pg_namespace.oid AND pg_attribute.attrelid = pg_class.oid AND pg_attribute.attnum = any(pg_index.indkey) AND indisprimary;"

            query = self.db.exec_(sql)
            clave = ""
            primero = True
            while query.next():
                if not primero:
                    clave += ","
                clave += query.value(0)
                primero = False

            # Obtengo todas las columnas, salvo la clave para inserts y updates
            sql = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + user + '_' + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + "' and table_schema = 'proyectos' "
            sql += "and column_name not in ('%s') " % (clave)
            sql += "and column_name in (SELECT column_name FROM information_schema.columns WHERE table_name = '" + tabla_name + "' and table_schema = 'public' ) "
            sql += "order by ordinal_position;"
            query = self.db.exec_(sql)
            campos = []
            while query.next():
                campos = campos + ['"' + str(query.value(0)) + '"']
            campos = ", ".join(campos)

            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Apply changes to Delete " + str(tabla) + "...", 100)
            progreso.setValue(33)

            for registro in ids_delete:


                sql = "delete from public.\"" + tabla_name + "\"  where \"%s\" = '%s';" % (clave, registro)
                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage(
                        "Error on commit delete for ID(" + str(registro) + ") in table " + tabla_name + ":\n" + str( query.lastError().text()), 'Edicion BTN PLUGIN')

            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Apply changes to New " + str(tabla) + "...", 100)
            progreso.setValue(66)

            for registro in ids_new:

                campos_insert = campos + ", \"" + clave + "\""
                sql = "INSERT INTO public.\"" + tabla_name + "\" ( " + campos_insert + ") OVERRIDING SYSTEM VALUE SELECT " + campos_insert + " FROM proyectos.\"" + user + '_' + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + "\" where " + clave + " = '" + registro + "' returning " + clave + ";"
                QgsMessageLog.logMessage(sql, 'Pruebas')
                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error on commit new record for ID(" + str(registro) + ") in table " + tabla_name + ":\n" + str(
                            query.lastError().text()), 'Edicion BTN PLUGIN')


            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Apply changes to Changes " + str(tabla) + "...", 100)
            progreso.setValue(99)

            for registro in ids_mods:


                sql = "update public.\"" + tabla_name + "\" SET (" + campos + ") = (SELECT " + campos + " FROM proyectos.\"" + user + '_' + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + "\" where " + clave + " = '" + registro + "' ) where " + clave + " = '" + registro + "' ;"
                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error on commit changes for ID(" + str(registro) + ") in table " + tabla_name + ":\n" + str(
                            query.lastError().text()), 'Edicion BTN PLUGIN')

            # Quitamos el mensaje de progreso en esta tabla
            self.iface.messageBar().clearWidgets()

        # Limpiamos seleccion antes de repoblarla, porque queda en memoria
        if not self.recheck:
            for tabla in self.dockwidget2.listWidget.selectedItems():
                tabla.setSelected(False)
            self.dockwidget2.listWidget.clear()
            layers = QgsProject.instance().mapLayers().values()
            layer_list = []
            for layer in layers:
                if "[" + self.loaded_type.lower() + "_" + project_name + "]" in layer.name():
                    layer_list.append(layer.name())
            self.dockwidget2.listWidget.addItems(layer_list)

        self.recheck_changes()
#Método que comprueba que los cambios ya se han subido a la BBDD y así asegurarse antes de eliminar el proyecto.
    def recheck_changes(self):
        # Recomprobación solo de los elementos seleccionados, para comprobar que ya se han subido a la base de datos
        self.db = QSqlDatabase.addDatabase("QPSQL")
        self.db.setHostName(self.hostname)
        self.db.setPort(self.port)
        self.db.setDatabaseName(self.database)
        self.db.setUserName(self.user)
        self.db.setPassword(self.password)
        self.db.open()



        # Obtenemos datos antiguos para conocer solo los seleccionados
        tablas = self.show_changes_tables
        dict_ids = self.diccionario_ids_tabla

        self.conflictwindow =EdicionBtnConflictWindow()
        self.conflictwindow.closingPlugin.connect(self.onClosePlugin)

        # Dejo solo un tab para limpiar previos
        for i in range(0, self.conflictwindow.tabWidget.count()):
            self.conflictwindow.tabWidget.removeTab(i)

        self.dict_results = collections.OrderedDict()
        progreso = self.showprogress("Checking changes...", len(tablas))
        contador = 0

        flag_old = ""
        sql = "SELECT \"valor\" from \"proyectos\".\"%s\" WHERE tabla = 'flag';" % (
                    self.user_u + "_" + self.loaded_type.lower() + "_" + self.loaded_proyect.lower())
        query = self.db.exec_(sql)
        while query.next():
            flag_old = query.value(0)

        project_name = self.loaded_proyect.lower()
        user = self.user_u

        for tabla in tablas:
            self.iface.messageBar().clearWidgets()
            progreso = self.showprogress("Checking changes...", len(tablas))
            progreso.setValue(contador)
            contador += 1

            temp = tabla
            tabla_name = temp[temp.rfind("[") + 1:-1]

            # "Calculamos primaria"
            sql = "SELECT pg_attribute.attname FROM pg_index, pg_class, pg_attribute, pg_namespace WHERE pg_class.oid = '%s'::regclass AND indrelid = pg_class.oid AND nspname = '%s' " % (
            tabla_name, 'public')
            sql += "and pg_class.relnamespace = pg_namespace.oid AND pg_attribute.attrelid = pg_class.oid AND pg_attribute.attnum = any(pg_index.indkey) AND indisprimary;"
            query = self.db.exec_(sql)
            primarias = ""
            primero = True
            while query.next():
                if not primero:
                    primarias += ","
                primarias += query.value(0)
                primero = False

            new_tab = QWidget()
            vBoxlayout = QVBoxLayout()
            self.dict_results[tabla] = EdicionBtn_ConflictWindow_Interno()
            vBoxlayout.addWidget(self.dict_results[tabla])
            new_tab.setLayout(vBoxlayout)

            # Obtengo todas las columnas comunes sin primaria
            sql = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + "' and table_schema = 'proyectos' "
            sql += "and column_name not in ('%s') " % (primarias)
            sql += "and column_name in (SELECT column_name FROM information_schema.columns WHERE table_name = '" + tabla_name + "' and table_schema = 'public' ) "
            sql += "order by ordinal_position;"

            query = self.db.exec_(sql)
            campos = []
            campos_public = []
            while query.next():
                campos = campos + [
                    '"' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '"."' + str(
                        query.value(0)) + '"']
                campos_public = campos_public + ['"' + tabla_name + '"."' + str(query.value(0)) + '"']
            campos = ", ".join(campos)
            campos_public = ", ".join(campos_public)

            # Solo se recomprueba si se selecciono algún nuevo
            if len(dict_ids[tabla][0]) > 0:
                # Calculamos nuevos con ID definitivo, por tanto cuyo id de primaria no exista en la principal
                sql = 'Select \'true\' AS "Commit", ' + primarias + ', ' + campos + ' from proyectos."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '" '
                sql += ' WHERE NOT EXISTS( Select "' + primarias + '" from "public"."' + tabla_name + '" as "secondary" where "secondary"."' + primarias + '" = "' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '"."' + primarias + '") '


                # Calculamos nuevos con ID definitivo, por tanto cuyo id de primaria no exista en la principal, al ser una recomprobación, solo miramos los IDS que marcamos anteriormente
                if tabla_name in ['btn0325s_embalse', 'btn0302s_rio', 'btn0665s_zon_ater_s', 'btn0662s_pis_ater',
                                  'btn0650s_est_fc', 'btn0567s_ins_rec_s', 'btn0613s_inf_trans_s',
                                  'btn0522s_cement', 'btn0504s_agr_edi', 'btn0513s_ins_ind', 'btn0564s_ins_dep',
                                  'btn0561s_zon_ver', 'btn0508s_ed', 'btn0331s_dep_agu', 'btn0328s_alm_agu',
                                  'btn0302l_rio',
                                  'btn0528l_cerram', 'btn0201l_cur_niv', 'btn0558p_yac_arq', 'btn0567p_ins_rec_p',
                                  'btn0525p_monume', 'btn0590p_ser_ins'] and tabla_name.split('_')[0].find('p') != -1:
                    sql += "AND ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'), geometry) "

                else:
                    sql += "AND ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'),st_centroid(geometry))"

                sql += ' AND "' + user + "_" + self.loaded_type.lower() + '_' + project_name + '_' + tabla_name + '"."' + primarias + '" in ' + "('" + "','".join(
                    dict_ids[tabla][0]) + "'); "
                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                        inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

                primer_registro = True
                self.dict_results[tabla].tableWidget.setRowCount(0)
                self.dict_results[tabla].bt_allnone_1.clicked.connect(
                    partial(self.changeAll, self.dict_results[tabla].tableWidget))
                while query.next():
                    record = query.record()
                    rowPosition = self.dict_results[tabla].tableWidget.rowCount()
                    self.dict_results[tabla].tableWidget.insertRow(rowPosition)
                    for i in range(0, record.count()):
                        if primer_registro:
                            self.dict_results[tabla].tableWidget.setColumnCount(record.count())
                            self.dict_results[tabla].tableWidget.setHorizontalHeaderItem(i, QTableWidgetItem(
                                str(record.fieldName(i))))
                            if i == 0:
                                self.dict_results[tabla].tableWidget.setColumnWidth(i, 50)

                        if str(record.value(i)) != "NULL":
                            if i == 0:
                                qwidget = QWidget()
                                checkbox = QCheckBox()
                                checkbox.setCheckState(Qt.Checked)
                                qhboxlayout = QHBoxLayout(qwidget)
                                qhboxlayout.addWidget(checkbox)
                                qhboxlayout.setAlignment(Qt.AlignCenter)
                                qhboxlayout.setContentsMargins(0, 0, 0, 0)
                                self.dict_results[tabla].tableWidget.setCellWidget(rowPosition, i, qwidget)
                            else:
                                self.dict_results[tabla].tableWidget.setItem(rowPosition, i,
                                                                             QTableWidgetItem(str(record.value(i))))

                    primer_registro = False
                if self.dict_results[tabla].tableWidget.rowCount() == 0:
                    self.dict_results[tabla].setTabEnabled(0, False)
                    self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                                  u"Se han guardado todos los nuevos registros de la tabla " + tabla + " : " + str(
                                      len(dict_ids[tabla][0])))
                else:
                    self.dict_results[tabla].setTabEnabled(0, True)
                    self.dict_results[tabla].setCurrentIndex(0)
                    self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                                  u"No se han guardado todos los nuevos registros de la tabla " + tabla + " : " + str(
                                      self.dict_results[tabla].tableWidget.rowCount()) + "/" + str(
                                      len(dict_ids[tabla][0])))

            else:
                self.dict_results[tabla].setTabEnabled(0, False)

            # Solo se recomprueba si se seleccionó algún eliminado
            if len(dict_ids[tabla][1]) > 0:
                sql = 'Select \'true\' AS "Commit", ' + primarias + ', ' + campos_public + ' from public."' + tabla_name + '" '

                # "Calculamos eliminados, cuyos id, de global, no aparezcan en temporal"
                if tabla_name in ['btn0325s_embalse', 'btn0302s_rio', 'btn0665s_zon_ater_s', 'btn0662s_pis_ater',
                                  'btn0650s_est_fc', 'btn0567s_ins_rec_s', 'btn0613s_inf_trans_s',
                                  'btn0522s_cement', 'btn0504s_agr_edi', 'btn0513s_ins_ind', 'btn0564s_ins_dep',
                                  'btn0561s_zon_ver', 'btn0508s_ed', 'btn0331s_dep_agu', 'btn0328s_alm_agu',
                                  'btn0302l_rio',
                                  'btn0528l_cerram', 'btn0201l_cur_niv', 'btn0558p_yac_arq', 'btn0567p_ins_rec_p',
                                  'btn0525p_monume', 'btn0590p_ser_ins'] and tabla_name.split('_')[0].find('p') != -1:
                    sql += "WHERE ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'), geometry) "
                else:
                    sql += "WHERE ST_Intersects((Select valor from \"proyectos\".\"" + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = 'geom'), st_centroid(geometry)) "

                sql += 'AND ' + primarias + ' in ' + "('" + "','".join(dict_ids[tabla][1]) + "') "
                sql += ' AND NOT EXISTS( Select "' + primarias + '" from "proyectos"."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "_" + tabla_name + '" as "secondary" where "secondary"."' + primarias + '" = "' + tabla_name + '"."' + primarias + '") '


                sql += 'AND ' + primarias + ' <= (Select max_id::numeric from "proyectos"."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = '" + tabla_name + "') "
                sql+= 'AND ' + primarias + ' >= (Select min_id::numeric from "proyectos"."' + user + "_" + self.loaded_type.lower() + "_" + project_name + "\" where tabla = '" + tabla_name + "'); "

                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                        inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

                primer_registro = True
                self.dict_results[tabla].tableWidget_2.setRowCount(0)
                self.dict_results[tabla].bt_allnone_2.clicked.connect(
                    partial(self.changeAll, self.dict_results[tabla].tableWidget_2))
                while query.next():
                    record = query.record()
                    rowPosition = self.dict_results[tabla].tableWidget_2.rowCount()
                    self.dict_results[tabla].tableWidget_2.insertRow(rowPosition)
                    error = False
                    for i in range(0, record.count()):
                        if primer_registro:
                            self.dict_results[tabla].tableWidget_2.setColumnCount(record.count())
                            self.dict_results[tabla].tableWidget_2.setHorizontalHeaderItem(i, QTableWidgetItem(
                                str(record.fieldName(i))))
                            if i == 0:
                                self.dict_results[tabla].tableWidget_2.setColumnWidth(i, 50)

                        if str(record.value(i)) != "NULL":
                            if i == 0:
                                qwidget = QWidget()
                                checkbox = QCheckBox()
                                checkbox.setCheckState(Qt.Checked)
                                qhboxlayout = QHBoxLayout(qwidget)
                                qhboxlayout.addWidget(checkbox)
                                qhboxlayout.setAlignment(Qt.AlignCenter)
                                qhboxlayout.setContentsMargins(0, 0, 0, 0)
                                self.dict_results[tabla].tableWidget_2.setCellWidget(rowPosition, i, qwidget)
                            else:
                                self.dict_results[tabla].tableWidget_2.setItem(rowPosition, i,
                                                                               QTableWidgetItem(str(record.value(i))))

                        elif str(record.value(i)) == "NULL":
                            self.dict_results[tabla].tableWidget_2.setItem(rowPosition, i, QTableWidgetItem(str("")))

                        if error:
                            self.dict_results[tabla.text()].tableWidget_2.item(rowPosition, i).setBackground(
                                QColor(200, 0, 0))

                    primer_registro = False
                if self.dict_results[tabla].tableWidget_2.rowCount() == 0:
                    self.dict_results[tabla].setTabEnabled(1, False)
                    self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                                  u"Se han guardado todas las eliminaciones de la tabla " + tabla + " : " + str(
                                      len(dict_ids[tabla][1])))
                else:
                    self.dict_results[tabla].setTabEnabled(1, True)
                    self.dict_results[tabla].setCurrentIndex(1)
                    self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                                  u"No se han guardado todas las eliminaciones de la tabla " + tabla + " : " + str(
                                      self.dict_results[tabla].tableWidget_2.rowCount()) + "/" + str(
                                      len(dict_ids[tabla][1])))

            else:
                self.dict_results[tabla].setTabEnabled(1, False)

            # Solo se recomprueba si se seleccionó algún modificado
            if len(dict_ids[tabla][2]) > 0:
                # "Calculamos cambios, de los que no sean null, mostramos los que tienen algun campo diferente"
                # "Obtenemos nombres de campos de temporal que ya tiene primaria el primer campo y así salen ordenados"
                sql = "SELECT column_name FROM information_schema.columns WHERE table_name = '" + user + '_' + self.loaded_type.lower() + "_" + project_name + '_' + tabla_name + "' and table_schema = 'proyectos' "
                sql += "and column_name in (SELECT column_name FROM information_schema.columns WHERE table_name = '" + tabla_name + "' and table_schema = 'public' ) "
                sql += "order by ordinal_position;"
                query = self.db.exec_(sql)
                campos = []
                while query.next():
                    campos = campos + [str(query.value(0))]

                # Calculamos cambios
                sql = 'Select \'true\' AS "Commit",'
                campos_temp = ""
                campos_original = ""
                primero = True
                for campo in campos:
                    if not primero:
                        campos_temp += ' , '
                        campos_original += ' , '
                    campos_temp += "temp." + campo
                    campos_original += "original." + campo
                    primero = False
                sql += campos_temp + ' , ' + campos_original
                sql += ' from public."' + tabla_name + '" as "original" RIGHT JOIN proyectos."' + user + '_' + self.loaded_type.lower() + "_" + project_name + '_' + tabla_name + '" as "temp" '
                sql += 'ON temp.' + primarias + ' = original.' + primarias
                sql += ' WHERE original.' + primarias + ' is not null AND temp.' + primarias + ' in ' + "('" + "','".join(
                    dict_ids[tabla][2]) + "') "
                if tabla_name in ["staxis", "stname"]:
                    sql += " AND temp.readonly = '0' "
                sql += ' and ('
                primero = True
                for campo in campos:
                    if not primero:
                        sql += ' OR '
                    if campo == self.column_geom:
                        sql += '((ST_ASTEXT(temp.%s) <> ST_ASTEXT(original.%s)) or (temp.%s is null and original.%s is not null) or (temp.%s is not null and original.%s is null))' % (
                        campo, campo, campo, campo, campo, campo)
                    else:
                        sql += '((temp.%s <> original.%s) or (temp.%s is null and original.%s is not null) or (temp.%s is not null and original.%s is null))' % (
                        campo, campo, campo, campo, campo, campo)
                    primero = False
                sql += ');'
                num_columnas_query = len(campos) + 1

                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                        inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

                primer_registro = True
                self.dict_results[tabla].tableWidget_3.setRowCount(0)
                self.dict_results[tabla].bt_allnone_3.clicked.connect(
                    partial(self.changeAll, self.dict_results[tabla].tableWidget_3))
                while query.next():
                    record = query.record()
                    rowPosition = self.dict_results[tabla].tableWidget_3.rowCount()
                    self.dict_results[tabla].tableWidget_3.insertRow(rowPosition)
                    error = False
                    for i in range(0, num_columnas_query):
                        if primer_registro:
                            self.dict_results[tabla].tableWidget_3.setColumnCount(num_columnas_query)
                            self.dict_results[tabla].tableWidget_3.setHorizontalHeaderItem(i, QTableWidgetItem(
                                str(record.fieldName(i))))
                            if i == 0:
                                self.dict_results[tabla].tableWidget_3.setColumnWidth(i, 50)

                        if i == 0:
                            qwidget = QWidget()
                            checkbox = QCheckBox()
                            checkbox.setCheckState(Qt.Checked)
                            qhboxlayout = QHBoxLayout(qwidget)
                            qhboxlayout.addWidget(checkbox)
                            qhboxlayout.setAlignment(Qt.AlignCenter)
                            qhboxlayout.setContentsMargins(0, 0, 0, 0)
                            self.dict_results[tabla].tableWidget_3.setCellWidget(rowPosition, i, qwidget)
                        else:
                            if str(record.value(i + num_columnas_query - 1)) == "NULL" and i == 1:
                                self.dict_results[tabla].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                    str(record.value(i)) + " has been deleted in main table"))
                                self.dict_results[tabla].tableWidget_3.setColumnWidth(i, 250)
                                error = True

                            elif str(record.value(i)) != "NULL" and str(
                                    record.value(i + num_columnas_query - 1)) != "NULL" and (
                                    str(record.value(i)) != str(record.value(i + num_columnas_query - 1))):
                                self.dict_results[tabla].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                    str(record.value(i + num_columnas_query - 1)) + " -> " + str(record.value(i))))
                                self.dict_results[tabla].tableWidget_3.item(rowPosition, i).setBackground(
                                    QColor(100, 200, 100))

                            elif str(record.value(i)) != "NULL" and str(
                                    record.value(i + num_columnas_query - 1)) == "NULL" and i != 0:
                                self.dict_results[tabla].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                    str(record.value(i + num_columnas_query - 1)) + " -> " + str(record.value(i))))
                                self.dict_results[tabla].tableWidget_3.item(rowPosition, i).setBackground(
                                    QColor(100, 200, 100))

                            elif str(record.value(i)) == "NULL" and str(
                                    record.value(i + num_columnas_query - 1)) != "NULL":
                                self.dict_results[tabla].tableWidget_3.setItem(rowPosition, i, QTableWidgetItem(
                                    str(record.value(i + num_columnas_query - 1)) + " -> " + str(record.value(i))))
                                self.dict_results[tabla].tableWidget_3.item(rowPosition, i).setBackground(
                                    QColor(100, 200, 100))

                            elif str(record.value(i)) == "NULL" and str(
                                    record.value(i + num_columnas_query - 1)) == "NULL":
                                self.dict_results[tabla].tableWidget_3.setItem(rowPosition, i,
                                                                               QTableWidgetItem(str("")))

                            else:
                                self.dict_results[tabla].tableWidget_3.setItem(rowPosition, i,
                                                                               QTableWidgetItem(str(record.value(i))))

                            if error:
                                self.dict_results[tabla].tableWidget_3.item(rowPosition, i).setBackground(
                                    QColor(200, 0, 0))

                    primer_registro = False

                if self.dict_results[tabla].tableWidget_3.rowCount() == 0:
                    self.dict_results[tabla].setTabEnabled(2, False)
                    self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                                  u"Se han guardado todas las modificaciones de la tabla " + tabla + " : " + str(
                                      len(dict_ids[tabla][2])))
                else:
                    self.dict_results[tabla].setTabEnabled(2, True)
                    self.dict_results[tabla].setCurrentIndex(2)
                    self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                                  u"No se han guardado todas las modificaciones de la tabla " + tabla + " : " + str(
                                      self.dict_results[tabla].tableWidget_3.rowCount()) + "/" + str(
                                      len(dict_ids[tabla][2])))
            else:
                self.dict_results[tabla].setTabEnabled(2, False)

            if self.dict_results[tabla].tableWidget.rowCount() == 0 and self.dict_results[
                tabla].tableWidget_2.rowCount() == 0 and self.dict_results[tabla].tableWidget_3.rowCount() == 0:
                del self.dict_results[tabla]
            else:
                self.conflictwindow.tabWidget.addTab(new_tab, tabla)

        self.iface.messageBar().clearWidgets()

        if self.conflictwindow.tabWidget.count() == 0:
            self.updateMainFlag("posteado")
            res = QMessageBox.information(self.iface.mainWindow(), "No new changes detected on recheck process",
                                          "No new changes detected on recheck process, all data is saved on main tables and working tables will be deleted",
                                          QMessageBox.Ok)



            # Borramos todas las tablas temporales asociadas al usuario y proyecto (Cambiamos la consulta haciendola especifica para el caso de que el nombre de un proyecto este integramente en el nombre de otro)
            project = user + '_' + self.loaded_type.lower() + "_" + self.loaded_proyect.lower()

            delete = True
            intentos = 0

            while delete:
                intentos += 1
                sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and table_name like '%{}%' ".format(project)
                query = self.db.exec_(sql)
                if query.lastError().isValid():
                    QgsMessageLog.logMessage("Error query:\n " + str(query.lastError().text()) + "\nLine: " + str(
                        inspect.currentframe().f_lineno), 'Edicion BTN PLUGIN')

                listado = []
                delete = False
                while query.next():
                    delete = True
                    listado = listado + [query.value(0)]

                if delete and intentos == 5:
                    QMessageBox.information(self.iface.mainWindow(), "Error",
                                            "Error on delete project, contact admin to complete \"%s\" " % (project))
                    QgsMessageLog.logMessage("Error on delete project, contact admin to complete \"%s\" " % (project),
                                             'Edicion BTN PLUGIN')
                    break

                for tabla_borrar in listado:
                    sql = 'DROP TABLE proyectos."%s" CASCADE;' % tabla_borrar
                    query = self.db.exec_(sql)

            layers = QgsProject.instance().mapLayers().values()
            for layer in layers:
                if "[" + self.loaded_type.lower() + "_" + self.loaded_proyect.lower() + "]" in layer.name():
                    QgsProject.instance().removeMapLayers([layer.id()])

            QMessageBox.information(self.iface.mainWindow(), "Done",
                                    "Changes saved on selected rows \n\nDeleted all working tables related to: \nUser = '%s'\nProject = '%s'" % (
                                    user, project_name))
            self.writelog(user, self.loaded_type.lower() + "_" + project_name,
                          u"Proyecto eliminado por el usuario tras confirmación de subirse todos los cambios seleccionados ")

            self.conflictwindow.close()
            self.onClosePlugin()

        else:
            self.conflictwindow.buttonBox.button(QDialogButtonBox.Save).clicked.connect(self.commit_changes)
            self.conflictwindow.show()
            self.conflictwindow.activateWindow()
            QMessageBox.critical(self.conflictwindow, "Error: Changes not saved",
                                 "Some changes has not been saved, check records for each tab to commit to main table, and try again \nIf error persists, check Edicion BTN PLUGIN log (in Log Messages Panel) and check for errors with same ID")
            self.recheck = True

        pass
#Método que actualiza el campo flag a posteado.
    def updateMainFlag(self, type):
        fecha_valor = str(time.strftime("%x") + " " + time.strftime("%X"))
        flag = "[%s][%s][%s][%s][%s]" % (
        type, fecha_valor, self.user_u, self.loaded_type.lower(), self.current_proyect.lower())

        # Update project
        sql = "update \"public\".\"%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'') where %s = '%s';" % (
        self.tabla_proy, flag, self.tabla_proy_field, self.project_clave)
        query = self.db.exec_(sql)

        # Update tables
        tables = {'btn0590p_ser_ins':'idprimary', 'btn0525p_monume':'idprimary', 'btn0567p_ins_rec_p':'idprimary', 'btn0558p_yac_arq':'idprimary', 'btn0201l_cur_niv':'idprimary', 'btn0302l_rio':'idprimary',
                                 'btn0528l_cerram':'idprimary','btn0328s_alm_agu':'idprimary','btn0331s_dep_agu':'idprimary','btn0650s_est_fc':'idprimary','btn0508s_ed':'idprimary','btn0561s_zon_ver':'idprimary','btn0567s_ins_rec_s':'idprimary',
                                 'btn0564s_ins_dep':'idprimary','btn0513s_ins_ind':'idprimary','btn0504s_agr_edi':'idprimary','btn0522s_cement':'idprimary','btn0613s_inf_trans_s':'idprimary','btn0662s_pis_ater':'idprimary','btn0665s_zon_ater_s':'idprimary'
                                 ,'btn0302s_rio':'idprimary','btn0325s_embalse':'idprimary'
                                 }
        for tabla in tables:
            # Compruebo si la tabla no existe
            sql = "SELECT * FROM pg_catalog.pg_tables WHERE  schemaname = 'proyectos' AND tablename  = '%s_%s_%s_%s'" % (
            self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla)
            query = self.db.exec_(sql)
            # If exists
            if query.size() > 0:
                sql = "update \"public\".\"%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'') where %s in (SELECT %s from \"proyectos\".\"%s_%s_%s_%s\");" % (
                tabla, flag, tables[tabla], tables[tabla], self.user_u, self.loaded_type.lower(),
                self.current_proyect.lower(), tabla)
                query = self.db.exec_(sql)

                sql = "update \"proyectos\".\"%s_%s_%s_%s\" set \"flag\" = '%s\n' || COALESCE(\"flag\",'');" % (
                self.user_u, self.loaded_type.lower(), self.current_proyect.lower(), tabla, flag)
                query = self.db.exec_(sql)

#Metodo que realiza los cambios de asignacion de proyecto, solo puede hacerlo el administrador.
    def run_admin_project(self):
        self.deactivate()
        self.iface.mapCanvas().setMapTool(self.toolPan)

        # Run method that loads and starts the plugin
        if not self.logged:
            self.login("run_admin_project")
            return
        if self.user_u =='postgres':
            self.admin = True
        if not self.admin:
            QMessageBox.critical(self.iface.mainWindow(), "Error", "Only admin can change project owner")
            return

        if self.pluginIsActive and self.dockwidget3 is None:
            self.onClosePlugin()

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget3 is None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget3 = EdicionBtnDockWidgetOwner()

            self.dockwidget3.closingPlugin.connect(self.onClosePlugin)

            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget3)
            self.dockwidget3.show()
            self.connectDB()
            self.dockwidget3.comboBox.clear()

            sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' and ((table_name like '%editor%'  or table_name like '%postgres%') and table_name not like '%btn%')  "

            query = self.db.exec_(sql)

            listado = [" "]
            while query.next():
                listado = listado + [query.value(0)]

            self.dockwidget3.comboBox.addItems(listado)
            self.dockwidget3.pushButton.clicked.connect(self.change_owner_project)
            self.dockwidget3.show()
        pass
#Método que reasigna proyectos a los editores posibles.
    def change_owner_project(self):
        project = str(self.dockwidget3.comboBox.currentText())
        if "_rev_" in project:
            owner = project[0:project.find("_rev_")]


        new_owner = str(self.dockwidget3.lineEdit.text()).strip()

        if project == " ":
            QMessageBox.warning(self.iface.mainWindow(), "Error", "No project selected")
            return

        if new_owner == "" or new_owner not in ('editor_1','editor_2'):
            QMessageBox.warning(self.iface.mainWindow(), "Error", "New owner is not valid")
            return

        sql = "Select table_name FROM information_schema.tables WHERE table_schema = 'proyectos' and table_type = 'BASE TABLE' AND "
        sql += "table_name like '%{}%' " .format(project)
        QgsMessageLog.logMessage("Error creating queries:\n" + sql ,
                                 'Edicion BTN PLUGIN')
        query = self.db.exec_(sql)

        listado = []
        while query.next():
            listado = listado + [query.value(0)]

        sql = ""
        for tabla in listado:
            nuevo = tabla.replace(owner, new_owner)

            sql += "ALTER TABLE \"proyectos\".\"" + tabla + "\" RENAME TO \"" + nuevo + "\";"

        if sql != "":
            query = self.db.exec_(sql)
            self.dockwidget3.close()

            if query.lastError().isValid():
                QgsMessageLog.logMessage("Error creating queries:\n" + str(query.lastError().text()),
                                         'Edicion BTN PLUGIN')
                QMessageBox.critical(self.iface.mainWindow(), "Error",
                                     "Error creating queries, check log to get more info")
            else:
                self.writelog(self.user_u, project,
                              u"El administrador " + self.user_u + " cambia el propietario del proyecto: " + owner + " -> " + new_owner)
                QMessageBox.information(self.iface.mainWindow(), "Done",
                                        "Project owner changed: \nOld = '%s'\nNew = '%s'" % (owner, new_owner))


        pass